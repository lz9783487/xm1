<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é€è§†å˜æ¢</title>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #f4f7f6; display: flex; flex-direction: column; align-items: center; padding: 20px; color: #333; }
        h2 { margin-bottom: 20px; }
        .controls { margin-bottom: 25px; display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        button, .btn-label { padding: 10px 24px; font-size: 14px; font-weight: 600; border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; display: inline-flex; align-items: center; justify-content: center; }
        .btn-primary { background: #007bff; color: white; }
        .btn-primary:hover { background: #0069d9; transform: translateY(-1px); }
        .btn-success { background: #28a745; color: white; }
        .btn-success:hover { background: #218838; transform: translateY(-1px); }
        input[type="file"] { display: none; }
        
        .workspace { display: flex; gap: 30px; flex-wrap: wrap; justify-content: center; width: 100%; max-width: 1200px; }
        .canvas-wrapper { display: flex; flex-direction: column; align-items: center; }
        .canvas-title { margin-bottom: 10px; font-weight: 600; color: #555; }
        .canvas-container { position: relative; box-shadow: 0 8px 20px rgba(0,0,0,0.1); background: white; border-radius: 8px; overflow: hidden; line-height: 0; user-select: none; touch-action: none; }
        canvas { display: block; max-width: 100%; height: auto; }
        
        /* æ‹–æ‹½ç‚¹æ ·å¼ä¼˜åŒ– */
        .handle {
            width: 24px; height: 24px; /* åŠ å¤§è§¦æ§åŒºåŸŸ */
            background: rgba(255, 69, 0, 0.8);
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.8), 0 4px 8px rgba(0,0,0,0.3);
            border-radius: 50%; position: absolute;
            transform: translate(-50%, -50%); cursor: grab; z-index: 20;
            transition: transform 0.1s, background 0.1s;
        }
        .handle:hover { transform: translate(-50%, -50%) scale(1.1); background: rgba(255, 69, 0, 1); }
        .handle:active { cursor: grabbing; transform: translate(-50%, -50%) scale(0.95); background: red; }
        
        /* åˆå§‹éšè—ç»“æœåŒº */
        #resultWrapper, #btnDownload { display: none; }
    </style>
</head>
<body>

    <h2>é€è§†å˜æ¢</h2>

    <div class="controls">
        <label for="upload" class="btn-label btn-primary">ğŸ“ 1. å¯¼å…¥å›¾ç‰‡</label>
        <input type="file" id="upload" accept="image/*">
        <button onclick="performTransform()" class="btn-primary">ğŸ”„ 2. æ‰§è¡Œå˜æ¢</button>
        <button onclick="downloadResult()" id="btnDownload" class="btn-success">â¬‡ï¸ 3. å¯¼å‡ºç»“æœ</button>
    </div>

    <div class="workspace">
        <div class="canvas-wrapper">
            <div class="canvas-title">åŸå›¾ (æ‹–æ‹½å››ä¸ªè§’å®šä½)</div>
            <div class="canvas-container" id="editorContainer">
                <canvas id="srcCanvas"></canvas>
                <div class="handle" id="p0"></div> <div class="handle" id="p1"></div> <div class="handle" id="p2"></div> <div class="handle" id="p3"></div> </div>
        </div>

        <div class="canvas-wrapper" id="resultWrapper">
            <div class="canvas-title">å˜æ¢ç»“æœ</div>
            <div class="canvas-container">
                <canvas id="dstCanvas"></canvas>
            </div>
        </div>
    </div>

<script>
    // --- æ ¸å¿ƒçŠ¶æ€ ---
    const srcCanvas = document.getElementById('srcCanvas');
    const dstCanvas = document.getElementById('dstCanvas');
    const ctxSrc = srcCanvas.getContext('2d', { willReadFrequently: true });
    const ctxDst = dstCanvas.getContext('2d');
    const editorContainer = document.getElementById('editorContainer');
    const handleElements = [
        document.getElementById('p0'),
        document.getElementById('p1'),
        document.getElementById('p2'),
        document.getElementById('p3')
    ];
    
    let img = new Image();
    // å­˜å‚¨4ä¸ªæ§åˆ¶ç‚¹åœ¨ Canvas åæ ‡ç³»ä¸­çš„ä½ç½® {x, y}
    let points = [{x:0, y:0}, {x:0, y:0}, {x:0, y:0}, {x:0, y:0}];
    let activePointIndex = -1; // å½“å‰æ­£åœ¨æ‹–æ‹½çš„ç‚¹çš„ç´¢å¼•

    // --- 1. åˆå§‹åŒ–ä¸å›¾ç‰‡åŠ è½½ ---
    document.getElementById('upload').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (event) => { img.src = event.target.result; };
        img.onload = () => { initWorkspace(); };
        reader.readAsDataURL(file);
    });

    function initWorkspace() {
        // è®¾ç½®ç”»å¸ƒä¸ºåŸå›¾å°ºå¯¸
        srcCanvas.width = img.width;
        srcCanvas.height = img.height;
        
        // åˆå§‹åŒ–4ä¸ªç‚¹çš„ä½ç½®ï¼šé»˜è®¤åœ¨ç”»å¸ƒè§’è½å¾€å†…ç¼©è¿›ä¸€ç‚¹
        const w = srcCanvas.width, h = srcCanvas.height;
        const padX = w * 0.15, padY = h * 0.15;
        points[0] = { x: padX, y: padY };             // TL
        points[1] = { x: w - padX, y: padY };         // TR
        points[2] = { x: w - padX, y: h - padY };     // BR
        points[3] = { x: padX, y: h - padY };         // BL

        drawEditor();
        // éšè—ä¸Šä¸€æ¬¡çš„ç»“æœ
        document.getElementById('resultWrapper').style.display = 'none';
        document.getElementById('btnDownload').style.display = 'none';
    }

    // ç»˜åˆ¶ç¼–è¾‘åŒºåŸŸï¼ˆèƒŒæ™¯å›¾ + è¿çº¿ + æ›´æ–°ç‚¹ä½ç½®ï¼‰
    function drawEditor() {
        ctxSrc.clearRect(0, 0, srcCanvas.width, srcCanvas.height);
        ctxSrc.drawImage(img, 0, 0);
        
        // ç»˜åˆ¶è¿æ¥çº¿
        ctxSrc.beginPath();
        ctxSrc.lineWidth = 3;
        ctxSrc.strokeStyle = 'rgba(0, 255, 0, 0.8)';
        ctxSrc.moveTo(points[0].x, points[0].y);
        ctxSrc.lineTo(points[1].x, points[1].y);
        ctxSrc.lineTo(points[2].x, points[2].y);
        ctxSrc.lineTo(points[3].x, points[3].y);
        ctxSrc.closePath();
        ctxSrc.stroke();

        // æ›´æ–° DOM èŠ‚ç‚¹ä½ç½®
        points.forEach((p, i) => {
            // ä½¿ç”¨ç™¾åˆ†æ¯”å®šä½ä»¥é€‚åº” CSS ç¼©æ”¾
            handleElements[i].style.left = (p.x / srcCanvas.width * 100) + '%';
            handleElements[i].style.top = (p.y / srcCanvas.height * 100) + '%';
        });
    }

    // --- 2. äº¤äº’äº‹ä»¶å¤„ç† (ä¿®å¤äº†ä¹‹å‰çš„ Bug) ---
    
    // è¾…åŠ©ï¼šè·å–äº‹ä»¶åœ¨ Canvas åæ ‡ç³»ä¸­çš„ä½ç½®
    function getEventPositionInCanvas(e) {
        const rect = srcCanvas.getBoundingClientRect();
        // å…¼å®¹é¼ æ ‡å’Œè§¦æ‘¸äº‹ä»¶
        const clientX = e.touches && e.touches.length > 0 ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches && e.touches.length > 0 ? e.touches[0].clientY : e.clientY;
        
        // è®¡ç®— CSS æ˜¾ç¤ºå°ºå¯¸ä¸ Canvas å®é™…åˆ†è¾¨ç‡çš„æ¯”ç‡
        const scaleX = srcCanvas.width / rect.width;
        const scaleY = srcCanvas.height / rect.height;

        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    // ç»‘å®šç‚¹çš„æŒ‰ä¸‹äº‹ä»¶
    handleElements.forEach((h, index) => {
        const startDrag = (e) => {
            e.preventDefault();
            e.stopPropagation();
            activePointIndex = index;
        };
        h.addEventListener('mousedown', startDrag);
        h.addEventListener('touchstart', startDrag, { passive: false });
    });

    // å…¨å±€ç§»åŠ¨å’Œæ¾å¼€äº‹ä»¶
    const moveHandler = (e) => {
        if (activePointIndex !== -1) {
            e.preventDefault(); // é˜²æ­¢æ»šåŠ¨
            const pos = getEventPositionInCanvas(e);
            // é™åˆ¶ç‚¹åœ¨ç”»å¸ƒèŒƒå›´å†…
            points[activePointIndex].x = Math.max(0, Math.min(srcCanvas.width, pos.x));
            points[activePointIndex].y = Math.max(0, Math.min(srcCanvas.height, pos.y));
            drawEditor();
        }
    };
    const endHandler = () => { activePointIndex = -1; };

    // å°†ç§»åŠ¨äº‹ä»¶ç»‘å®šåœ¨ document ä¸Šä»¥ä¿è¯æ‹–å‡ºå®¹å™¨ä¹Ÿèƒ½å“åº”ï¼Œä½†é™å®šåœ¨ containeråŒºåŸŸå†…è§¦å‘
    editorContainer.addEventListener('mousemove', moveHandler);
    editorContainer.addEventListener('touchmove', moveHandler, { passive: false });
    window.addEventListener('mouseup', endHandler);
    window.addEventListener('touchend', endHandler);


    // --- 3. æ ¸å¿ƒç®—æ³•ï¼šæ‰§è¡Œé€è§†å˜æ¢ ---
    function performTransform() {
        if (!img.src) return alert("è¯·å…ˆå¯¼å…¥å›¾ç‰‡");

        // 3.1 ä¼°ç®—è¾“å‡ºçŸ©å½¢çš„åˆç†å®½é«˜
        // è®¡ç®—å››è¾¹å½¢çš„å››æ¡è¾¹é•¿
        const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        const wTop = dist(points[0], points[1]);
        const wBottom = dist(points[3], points[2]);
        const hLeft = dist(points[0], points[3]);
        const hRight = dist(points[1], points[2]);
        
        //å–æœ€é•¿è¾¹ä½œä¸ºè¾“å‡ºå°ºå¯¸ï¼Œä¿è¯æ¸…æ™°åº¦
        const outW = Math.round(Math.max(wTop, wBottom));
        const outH = Math.round(Math.max(hLeft, hRight));

        dstCanvas.width = outW;
        dstCanvas.height = outH;

        // 3.2 è·å–å›¾åƒæ•°æ®
        const srcImageData = ctxSrc.getImageData(0, 0, srcCanvas.width, srcCanvas.height);
        const dstImageData = ctxDst.createImageData(outW, outH);
        const srcData = srcImageData.data;
        const dstData = dstImageData.data;
        const srcW = srcCanvas.width; srcH = srcCanvas.height;

        // 3.3 è®¡ç®—å•åº”æ€§çŸ©é˜µ (Homography Matrix)
        // æˆ‘ä»¬éœ€è¦ä¸€ä¸ªçŸ©é˜µï¼Œå®ƒèƒ½æŠŠç›®æ ‡çŸ©å½¢ä¸Šçš„ç‚¹ (u,v) æ˜ å°„å›åŸå›¾ä¸Šçš„ç‚¹ (x,y)
        const targetRect = [
            {x: 0, y: 0},       // TL
            {x: outW, y: 0},    // TR
            {x: outW, y: outH}, // BR
            {x: 0, y: outH}     // BL
        ];
        // è®¡ç®—ä» ç›®æ ‡(Rect) -> æº(Quad) çš„é€†å‘æ˜ å°„çŸ©é˜µ
        const H = calcHomography(targetRect, points);

        if (!H) return alert("çŸ©é˜µè®¡ç®—å¤±è´¥ï¼Œè¯·è°ƒæ•´ç‚¹çš„ä½ç½®å°è¯•");

        // 3.4 åƒç´ é‡é‡‡æ · (åå‘æ˜ å°„éå†)
        for (let v = 0; v < outH; v++) {
            for (let u = 0; u < outW; u++) {
                // åº”ç”¨çŸ©é˜µ H æŠŠç›®æ ‡åæ ‡ (u,v) æ˜ å°„å›æºåæ ‡
                const denom = H[6]*u + H[7]*v + H[8];
                const x_src = (H[0]*u + H[1]*v + H[2]) / denom;
                const y_src = (H[3]*u + H[4]*v + H[5]) / denom;

                // æœ€è¿‘é‚»æ’å€¼ (Nearest Neighbor) - ç®€å•é«˜æ•ˆ
                const x = Math.round(x_src);
                const y = Math.round(y_src);

                // è¾¹ç•Œæ£€æŸ¥ï¼Œç¡®ä¿åœ¨åŸå›¾èŒƒå›´å†…
                if (x >= 0 && x < srcW && y >= 0 && y < srcH) {
                    const dstIdx = (v * outW + u) * 4;
                    const srcIdx = (y * srcW + x) * 4;
                    dstData[dstIdx]     = srcData[srcIdx];     // R
                    dstData[dstIdx + 1] = srcData[srcIdx + 1]; // G
                    dstData[dstIdx + 2] = srcData[srcIdx + 2]; // B
                    dstData[dstIdx + 3] = 255;                 // A (ä¸é€æ˜)
                }
            }
        }

        // 3.5 æ˜¾ç¤ºç»“æœ
        ctxDst.putImageData(dstImageData, 0, 0);
        document.getElementById('resultWrapper').style.display = 'flex';
        document.getElementById('btnDownload').style.display = 'inline-flex';
    }

    // --- 4. å¯¼å‡ºåŠŸèƒ½ ---
    function downloadResult() {
        const link = document.createElement('a');
        // ä½¿ç”¨æ—¶é—´æˆ³ç”Ÿæˆæ–‡ä»¶å
        link.download = `warp_result_${new Date().getTime()}.png`;
        // toDataURL åœ¨æœ¬åœ°ç¯å¢ƒä¸‹é€šå¸¸æ²¡é—®é¢˜ï¼Œè·¨åŸŸå›¾ç‰‡å¯èƒ½ä¼šæ±¡æŸ“ç”»å¸ƒå¯¼è‡´å¤±è´¥
        try {
            link.href = dstCanvas.toDataURL('image/png');
            link.click();
        } catch (e) {
            alert("å¯¼å‡ºå¤±è´¥ï¼Œå¯èƒ½æ˜¯è·¨åŸŸå®‰å…¨é™åˆ¶å¯¼è‡´ã€‚");
            console.error(e);
        }
    }


    // ==========================================
    // æ•°å­¦åº“ï¼šè®¡ç®—å•åº”æ€§çŸ©é˜µ (Homography)
    // æ›¿æ¢äº†ä¹‹å‰ä¸ç¨³å®šçš„å®ç°ï¼Œé‡‡ç”¨äº†æ›´æ ‡å‡†çš„è§£æ³•ã€‚
    // è¿™ç§æ–¹æ³•æœ¬è´¨ä¸Šæ˜¯æ±‚è§£ Ah = 0 çš„çº¿æ€§æ–¹ç¨‹ç»„ï¼Œè¿™é‡Œä½¿ç”¨äº†ç®€åŒ–çš„ä»£æ•°æ–¹æ³•ã€‚
    // ==========================================
    function calcHomography(src, dst) {
        // src æ˜¯æ ‡å‡†çŸ©å½¢çš„4ä¸ªç‚¹ï¼Œdst æ˜¯ä»»æ„å››è¾¹å½¢çš„4ä¸ªç‚¹
        let x0 = src[0].x, y0 = src[0].y, u0 = dst[0].x, v0 = dst[0].y;
        let x1 = src[1].x, y1 = src[1].y, u1 = dst[1].x, v1 = dst[1].y;
        let x2 = src[2].x, y2 = src[2].y, u2 = dst[2].x, v2 = dst[2].y;
        let x3 = src[3].x, y3 = src[3].y, u3 = dst[3].x, v3 = dst[3].y;

        // ä½¿ç”¨é«˜æ–¯æ¶ˆå…ƒæ³•æ±‚è§£ 8å…ƒçº¿æ€§æ–¹ç¨‹ç»„
        // Matrix form A * H = B
        let A = [
            [x0, y0, 1, 0, 0, 0, -u0*x0, -u0*y0],
            [0, 0, 0, x0, y0, 1, -v0*x0, -v0*y0],
            [x1, y1, 1, 0, 0, 0, -u1*x1, -u1*y1],
            [0, 0, 0, x1, y1, 1, -v1*x1, -v1*y1],
            [x2, y2, 1, 0, 0, 0, -u2*x2, -u2*y2],
            [0, 0, 0, x2, y2, 1, -v2*x2, -v2*y2],
            [x3, y3, 1, 0, 0, 0, -u3*x3, -u3*y3],
            [0, 0, 0, x3, y3, 1, -v3*x3, -v3*y3]
        ];
        let B = [u0, v0, u1, v1, u2, v2, u3, v3];

        // Gaussian elimination with partial pivoting
        const n = 8;
        for (let i = 0; i < n; i++) {
            let maxRow = i;
            for (let k = i + 1; k < n; k++) {
                if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) {
                    maxRow = k;
                }
            }
            // Swap rows
            [A[i], A[maxRow]] = [A[maxRow], A[i]];
            [B[i], B[maxRow]] = [B[maxRow], B[i]];

            // Make A[i][i] equal to 1
            let pivot = A[i][i];
            if (Math.abs(pivot) < 1e-10) return null; // Matrix is singular

            for (let j = i; j < n; j++) A[i][j] /= pivot;
            B[i] /= pivot;

            // Eliminate other rows
            for (let k = 0; k < n; k++) {
                if (k !== i) {
                    let factor = A[k][i];
                    for (let j = i; j < n; j++) A[k][j] -= factor * A[i][j];
                    B[k] -= factor * B[i];
                }
            }
        }
        
        // The result H is now in B, append H[8] = 1
        return [...B, 1];
    }

</script>
</body>
</html>