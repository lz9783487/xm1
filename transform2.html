<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é€è§†å˜æ¢ (æ”¯æŒè¶…ç•Œå¡«å……)</title>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #f4f7f6; display: flex; flex-direction: column; align-items: center; padding: 20px; color: #333; }
        h2 { margin-bottom: 20px; }
        .controls { margin-bottom: 25px; display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); z-index: 100; }
        button, .btn-label { padding: 10px 24px; font-size: 14px; font-weight: 600; border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; display: inline-flex; align-items: center; justify-content: center; }
        .btn-primary { background: #007bff; color: white; }
        .btn-primary:hover { background: #0069d9; transform: translateY(-1px); }
        .btn-success { background: #28a745; color: white; }
        .btn-success:hover { background: #218838; transform: translateY(-1px); }
        input[type="file"] { display: none; }
        
        .workspace { display: flex; gap: 50px; flex-wrap: wrap; justify-content: center; width: 100%; max-width: 1200px; padding: 20px; }
        .canvas-wrapper { display: flex; flex-direction: column; align-items: center; }
        .canvas-title { margin-bottom: 10px; font-weight: 600; color: #555; }
        
        /* ä¿®æ”¹ 1: å…è®¸å†…å®¹æº¢å‡ºï¼Œå¢åŠ è¾¹è·ä»¥ä¾¿èƒ½çœ‹åˆ°å¤–é¢çš„ç‚¹ */
        .canvas-container { 
            position: relative; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.1); 
            background: white; 
            /* overflow: hidden;  <-- åˆ é™¤è¿™ä¸€è¡Œï¼Œå…è®¸ç‚¹è·‘å‡ºå» */
            overflow: visible; 
            border-radius: 8px; 
            line-height: 0; 
            user-select: none; 
            touch-action: none; 
            margin: 20px; /* å¢åŠ å¤–è¾¹è·ï¼Œé˜²æ­¢ç‚¹æ‹–å‡ºå»è¢«å…¶ä»–å…ƒç´ æŒ¡ä½ */
        }
        canvas { display: block; max-width: 100%; height: auto; }
        
        .handle {
            width: 24px; height: 24px;
            background: rgba(255, 69, 0, 0.8);
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.8), 0 4px 8px rgba(0,0,0,0.3);
            border-radius: 50%; position: absolute;
            transform: translate(-50%, -50%); cursor: grab; z-index: 20;
            transition: transform 0.1s, background 0.1s;
        }
        .handle:hover { transform: translate(-50%, -50%) scale(1.1); background: rgba(255, 69, 0, 1); }
        .handle:active { cursor: grabbing; transform: translate(-50%, -50%) scale(0.95); background: red; }
        
        #resultWrapper, #btnDownload { display: none; }
    </style>
</head>
<body>

    <h2>é€è§†å˜æ¢ (æ”¯æŒè¾¹ç•Œå¤–å¡«å……)</h2>

    <div class="controls">
        <label for="upload" class="btn-label btn-primary">ğŸ“ 1. å¯¼å…¥å›¾ç‰‡</label>
        <input type="file" id="upload" accept="image/*">
        <button onclick="performTransform()" class="btn-primary">ğŸ”„ 2. æ‰§è¡Œå˜æ¢</button>
        <button onclick="downloadResult()" id="btnDownload" class="btn-success">â¬‡ï¸ 3. å¯¼å‡ºç»“æœ</button>
    </div>

    <div class="workspace">
        <div class="canvas-wrapper">
            <div class="canvas-title">åŸå›¾ (å¯æ‹–æ‹½è‡³ç”»é¢å¤–)</div>
            <div class="canvas-container" id="editorContainer">
                <canvas id="srcCanvas"></canvas>
                <div class="handle" id="p0"></div> <div class="handle" id="p1"></div> <div class="handle" id="p2"></div> <div class="handle" id="p3"></div> </div>
        </div>

        <div class="canvas-wrapper" id="resultWrapper">
            <div class="canvas-title">å˜æ¢ç»“æœ</div>
            <div class="canvas-container">
                <canvas id="dstCanvas"></canvas>
            </div>
        </div>
    </div>

<script>
    const srcCanvas = document.getElementById('srcCanvas');
    const dstCanvas = document.getElementById('dstCanvas');
    const ctxSrc = srcCanvas.getContext('2d', { willReadFrequently: true });
    const ctxDst = dstCanvas.getContext('2d');
    const editorContainer = document.getElementById('editorContainer');
    const handleElements = [
        document.getElementById('p0'),
        document.getElementById('p1'),
        document.getElementById('p2'),
        document.getElementById('p3')
    ];
    
    let img = new Image();
    let points = [{x:0, y:0}, {x:0, y:0}, {x:0, y:0}, {x:0, y:0}];
    let activePointIndex = -1;

    // --- 1. åˆå§‹åŒ–ä¸å›¾ç‰‡åŠ è½½ ---
    document.getElementById('upload').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (event) => { img.src = event.target.result; };
        img.onload = () => { initWorkspace(); };
        reader.readAsDataURL(file);
    });

    function initWorkspace() {
        srcCanvas.width = img.width;
        srcCanvas.height = img.height;
        
        const w = srcCanvas.width, h = srcCanvas.height;
        // é»˜è®¤è¿˜æ˜¯æ”¾åœ¨å†…éƒ¨ï¼Œä½†ç°åœ¨ç”¨æˆ·å¯ä»¥æ‹–å‡ºå»äº†
        const padX = w * 0.15, padY = h * 0.15;
        points[0] = { x: padX, y: padY };             
        points[1] = { x: w - padX, y: padY };         
        points[2] = { x: w - padX, y: h - padY };     
        points[3] = { x: padX, y: h - padY };         

        drawEditor();
        document.getElementById('resultWrapper').style.display = 'none';
        document.getElementById('btnDownload').style.display = 'none';
    }

    function drawEditor() {
        ctxSrc.clearRect(0, 0, srcCanvas.width, srcCanvas.height);
        ctxSrc.drawImage(img, 0, 0);
        
        ctxSrc.beginPath();
        ctxSrc.lineWidth = 3;
        ctxSrc.strokeStyle = 'rgba(0, 255, 0, 0.8)';
        // è¿™é‡Œçš„åæ ‡å¦‚æœæ˜¯è´Ÿæ•°æˆ–è¶…è¿‡å®½é«˜ï¼ŒCanvas ä¼šè‡ªåŠ¨å¤„ç†ï¼ˆç”»åœ¨ç”»å¸ƒå¤–ä¸å¯è§åŒºåŸŸï¼‰ï¼Œ
        // ä½†æˆ‘ä»¬éœ€è¦è¿çº¿ï¼Œæ‰€ä»¥ç›´æ¥ç”»å³å¯ã€‚
        ctxSrc.moveTo(points[0].x, points[0].y);
        ctxSrc.lineTo(points[1].x, points[1].y);
        ctxSrc.lineTo(points[2].x, points[2].y);
        ctxSrc.lineTo(points[3].x, points[3].y);
        ctxSrc.closePath();
        ctxSrc.stroke();

        points.forEach((p, i) => {
            // æ³¨æ„ï¼šè¿™é‡Œå¯èƒ½äº§ç”Ÿè´Ÿç™¾åˆ†æ¯”æˆ– >100%ï¼ŒCSS å…è®¸è¿™æ ·åšï¼Œç‚¹ä¼šè·‘åˆ°å®¹å™¨å¤–é¢
            handleElements[i].style.left = (p.x / srcCanvas.width * 100) + '%';
            handleElements[i].style.top = (p.y / srcCanvas.height * 100) + '%';
        });
    }

    // --- 2. äº¤äº’äº‹ä»¶å¤„ç† ---
    
    function getEventPositionInCanvas(e) {
        const rect = srcCanvas.getBoundingClientRect();
        const clientX = e.touches && e.touches.length > 0 ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches && e.touches.length > 0 ? e.touches[0].clientY : e.clientY;
        
        const scaleX = srcCanvas.width / rect.width;
        const scaleY = srcCanvas.height / rect.height;

        // è¿™é‡Œçš„ x, y å¯èƒ½æ˜¯è´Ÿæ•°ï¼Œä¹Ÿå¯èƒ½å¤§äº width/heightï¼Œè¿™æ˜¯æˆ‘ä»¬è¦çš„æ•ˆæœ
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    handleElements.forEach((h, index) => {
        const startDrag = (e) => {
            e.preventDefault(); e.stopPropagation();
            activePointIndex = index;
        };
        h.addEventListener('mousedown', startDrag);
        h.addEventListener('touchstart', startDrag, { passive: false });
    });

    const moveHandler = (e) => {
        if (activePointIndex !== -1) {
            e.preventDefault();
            const pos = getEventPositionInCanvas(e);
            
            // ä¿®æ”¹ 2: ç§»é™¤ Math.max å’Œ Math.min çš„é™åˆ¶ï¼Œå…è®¸è‡ªç”±æ‹–åŠ¨
            points[activePointIndex].x = pos.x;
            points[activePointIndex].y = pos.y;
            
            drawEditor();
        }
    };
    const endHandler = () => { activePointIndex = -1; };

    // äº‹ä»¶ç»‘å®šåˆ° window ç¡®ä¿å³ä¾¿é¼ æ ‡ç§»å‡ºæµè§ˆå™¨çª—å£ä¹Ÿèƒ½å“åº”ï¼ˆä¸€å®šç¨‹åº¦ï¼‰
    window.addEventListener('mousemove', moveHandler);
    window.addEventListener('touchmove', moveHandler, { passive: false });
    window.addEventListener('mouseup', endHandler);
    window.addEventListener('touchend', endHandler);


    // --- 3. æ ¸å¿ƒç®—æ³• ---
    
    // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—å›¾ç‰‡çš„å¹³å‡é¢œè‰²
    function getAverageColor(context, width, height) {
        try {
            const data = context.getImageData(0, 0, width, height).data;
            let r = 0, g = 0, b = 0;
            let count = 0;
            // é‡‡æ ·æ­¥é•¿ï¼Œæ¯ 10 ä¸ªåƒç´ é‡‡ä¸€ä¸ªï¼Œæé«˜æ€§èƒ½
            const step = 10; 
            for (let i = 0; i < data.length; i += 4 * step) {
                r += data[i];
                g += data[i + 1];
                b += data[i + 2];
                count++;
            }
            return {
                r: Math.round(r / count),
                g: Math.round(g / count),
                b: Math.round(b / count)
            };
        } catch (e) {
            // å¦‚æœå‡ºé”™ï¼ˆæ¯”å¦‚è·¨åŸŸï¼‰ï¼Œé»˜è®¤è¿”å›ç°è‰²
            return { r: 128, g: 128, b: 128 };
        }
    }

    function performTransform() {
        if (!img.src) return alert("è¯·å…ˆå¯¼å…¥å›¾ç‰‡");

        const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        const wTop = dist(points[0], points[1]);
        const wBottom = dist(points[3], points[2]);
        const hLeft = dist(points[0], points[3]);
        const hRight = dist(points[1], points[2]);
        
        const outW = Math.round(Math.max(wTop, wBottom));
        const outH = Math.round(Math.max(hLeft, hRight));

        dstCanvas.width = outW;
        dstCanvas.height = outH;

        // è·å–åŸå›¾æ•°æ®
        const srcImageData = ctxSrc.getImageData(0, 0, srcCanvas.width, srcCanvas.height);
        const dstImageData = ctxDst.createImageData(outW, outH);
        const srcData = srcImageData.data;
        const dstData = dstImageData.data;
        const srcW = srcCanvas.width; srcH = srcCanvas.height;

        // è®¡ç®—å¹³å‡é¢œè‰²ç”¨äºå¡«å……
        const avgColor = getAverageColor(ctxSrc, srcW, srcH);
        // å¦‚æœæƒ³è¦çº¯é»‘è‰²ï¼Œå¯ä»¥è§£å¼€ä¸‹é¢è¿™è¡Œ
        // const avgColor = { r: 0, g: 0, b: 0 }; 

        const targetRect = [
            {x: 0, y: 0}, 
            {x: outW, y: 0}, 
            {x: outW, y: outH}, 
            {x: 0, y: outH} 
        ];
        
        const H = calcHomography(targetRect, points);
        if (!H) return alert("çŸ©é˜µè®¡ç®—å¤±è´¥");

        // 3.4 åƒç´ é‡é‡‡æ ·
        for (let v = 0; v < outH; v++) {
            for (let u = 0; u < outW; u++) {
                const denom = H[6]*u + H[7]*v + H[8];
                const x_src = (H[0]*u + H[1]*v + H[2]) / denom;
                const y_src = (H[3]*u + H[4]*v + H[5]) / denom;

                const x = Math.round(x_src);
                const y = Math.round(y_src);
                
                const dstIdx = (v * outW + u) * 4;

                // ä¿®æ”¹ 3: è¾¹ç•Œæ£€æŸ¥é€»è¾‘
                if (x >= 0 && x < srcW && y >= 0 && y < srcH) {
                    // åœ¨åŸå›¾èŒƒå›´å†…ï¼šç›´æ¥å¤åˆ¶
                    const srcIdx = (y * srcW + x) * 4;
                    dstData[dstIdx]     = srcData[srcIdx];     
                    dstData[dstIdx + 1] = srcData[srcIdx + 1]; 
                    dstData[dstIdx + 2] = srcData[srcIdx + 2]; 
                    dstData[dstIdx + 3] = 255;                 
                } else {
                    // è¶…å‡ºèŒƒå›´ï¼šå¡«å……å¹³å‡è‰² (æˆ–è€…ä½ å¯ä»¥æ”¹æˆé»‘è‰²/ç°è‰²)
                    dstData[dstIdx]     = avgColor.r;
                    dstData[dstIdx + 1] = avgColor.g;
                    dstData[dstIdx + 2] = avgColor.b;
                    dstData[dstIdx + 3] = 255; // å®Œå…¨ä¸é€æ˜
                }
            }
        }

        ctxDst.putImageData(dstImageData, 0, 0);
        document.getElementById('resultWrapper').style.display = 'flex';
        document.getElementById('btnDownload').style.display = 'inline-flex';
    }

    function downloadResult() {
        const link = document.createElement('a');
        link.download = `warp_result_${new Date().getTime()}.png`;
        try {
            link.href = dstCanvas.toDataURL('image/png');
            link.click();
        } catch (e) {
            alert("å¯¼å‡ºå¤±è´¥ï¼Œå¯èƒ½æ˜¯è·¨åŸŸå®‰å…¨é™åˆ¶å¯¼è‡´ã€‚");
        }
    }

    // è®¡ç®—å•åº”æ€§çŸ©é˜µ (ä¿æŒä¸å˜)
    function calcHomography(src, dst) {
        let x0 = src[0].x, y0 = src[0].y, u0 = dst[0].x, v0 = dst[0].y;
        let x1 = src[1].x, y1 = src[1].y, u1 = dst[1].x, v1 = dst[1].y;
        let x2 = src[2].x, y2 = src[2].y, u2 = dst[2].x, v2 = dst[2].y;
        let x3 = src[3].x, y3 = src[3].y, u3 = dst[3].x, v3 = dst[3].y;

        let A = [
            [x0, y0, 1, 0, 0, 0, -u0*x0, -u0*y0],
            [0, 0, 0, x0, y0, 1, -v0*x0, -v0*y0],
            [x1, y1, 1, 0, 0, 0, -u1*x1, -u1*y1],
            [0, 0, 0, x1, y1, 1, -v1*x1, -v1*y1],
            [x2, y2, 1, 0, 0, 0, -u2*x2, -u2*y2],
            [0, 0, 0, x2, y2, 1, -v2*x2, -v2*y2],
            [x3, y3, 1, 0, 0, 0, -u3*x3, -u3*y3],
            [0, 0, 0, x3, y3, 1, -v3*x3, -v3*y3]
        ];
        let B = [u0, v0, u1, v1, u2, v2, u3, v3];

        const n = 8;
        for (let i = 0; i < n; i++) {
            let maxRow = i;
            for (let k = i + 1; k < n; k++) {
                if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) {
                    maxRow = k;
                }
            }
            [A[i], A[maxRow]] = [A[maxRow], A[i]];
            [B[i], B[maxRow]] = [B[maxRow], B[i]];

            let pivot = A[i][i];
            if (Math.abs(pivot) < 1e-10) return null;

            for (let j = i; j < n; j++) A[i][j] /= pivot;
            B[i] /= pivot;

            for (let k = 0; k < n; k++) {
                if (k !== i) {
                    let factor = A[k][i];
                    for (let j = i; j < n; j++) A[k][j] -= factor * A[i][j];
                    B[k] -= factor * B[i];
                }
            }
        }
        return [...B, 1];
    }
</script>
</body>
</html>