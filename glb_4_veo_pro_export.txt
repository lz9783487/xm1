===== index.html =====
<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ¨¡å‹è§†é¢‘æ˜ å°„ (8ç‚¹é€è§†æ¡†é€‰)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            font-family: sans-serif;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
        }

        .ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: #eee;
            border: 1px solid #444;
            backdrop-filter: blur(5px);
        }

        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 5px;
            font-size: 12px;
        }

        button:hover {
            background: #005bb5;
        }

        .status {
            margin-top: 10px;
            font-size: 12px;
            color: #00ff99;
        }

        #editorModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .toolbar {
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            background: #222;
            padding: 10px;
            border-radius: 8px;
            justify-content: center;
        }

        .toolbar span {
            color: #00ff99;
            line-height: 30px;
            margin-right: 10px;
        }

        #regionCanvas {
            border: 2px solid #333;
            cursor: crosshair;
            background: #000;
        }

        .handle {
            width: 18px;
            height: 18px;
            background: rgba(255, 69, 0, 0.9);
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            cursor: grab;
            z-index: 20;
        }

        .handle.front {
            background: rgba(0, 150, 255, 0.9);
        }

        .handle::after {
            content: attr(data-label);
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 11px;
            white-space: nowrap;
        }

        .editor-container {
            position: relative;
            line-height: 0;
            user-select: none;
        }

        .legend {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
            text-align: center;
        }

        .legend span {
            margin: 0 10px;
        }

        .legend .back-color {
            color: #FF4500;
        }

        .legend .front-color {
            color: #0096FF;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>

<body>

    <div class="ui-layer">
        <h3 style="margin-top:0">æ§åˆ¶å°</h3>
        <div>
            <input type="file" id="videoInput" accept="video/*" style="display:none">
            <button onclick="document.getElementById('videoInput').click()">ğŸ“‚ åŠ è½½æœ¬åœ°è§†é¢‘</button>
            <button onclick="startWebcam()">ğŸ“· ä½¿ç”¨æ‘„åƒå¤´</button>
        </div>
        <div style="margin-top: 10px; border-top: 1px solid #444; padding-top: 10px;">
            <div style="margin-bottom: 10px;">
                <label style="color: #ccc;">
                    <input type="checkbox" id="enableDewarp" checked onchange="toggleDewarp(this.checked)">
                    å¯ç”¨é€è§†æ ¡æ­£
                </label>
            </div>
            <button onclick="openEditor()" id="btnEdit" style="background: #e65c00; width: 100%; display:none">âœï¸
                æ¡†é€‰åŒºåŸŸ (8ç‚¹)</button>
        </div>
        <div id="status" class="status">æ­£åœ¨åˆå§‹åŒ–...</div>
    </div>

    <div id="editorModal">
        <div class="toolbar">
            <span>æ‹–åŠ¨8ä¸ªæ§åˆ¶ç‚¹è°ƒæ•´é€è§†åŒºåŸŸ</span>
            <button onclick="selector.save()" style="background: #00cc66;">âœ… å®Œæˆå¹¶åº”ç”¨</button>
            <button onclick="selector.close()" style="background: #666;">âŒ å–æ¶ˆ</button>
        </div>
        <div class="editor-container" id="editorStage">
            <canvas id="regionCanvas"></canvas>
            <!-- 8ä¸ªæ‹–æ‹½ç‚¹: 0-3å†…æ¡†(åå¢™), 4-7å¤–æ¡†(å‰æ¡†) -->
            <div class="handle back" id="h0" data-label="åå·¦ä¸Š"></div>
            <div class="handle back" id="h1" data-label="åå³ä¸Š"></div>
            <div class="handle back" id="h2" data-label="åå·¦ä¸‹"></div>
            <div class="handle back" id="h3" data-label="åå³ä¸‹"></div>
            <div class="handle front" id="h4" data-label="å‰å·¦ä¸Š"></div>
            <div class="handle front" id="h5" data-label="å‰å³ä¸Š"></div>
            <div class="handle front" id="h6" data-label="å‰å·¦ä¸‹"></div>
            <div class="handle front" id="h7" data-label="å‰å³ä¸‹"></div>
        </div>
        <div class="legend">
            <span class="back-color">â— å†…æ¡†(åå¢™/å‰é¢)</span>
            <span class="front-color">â— å¤–æ¡†(å‰æ¡†)</span>
            <span>| çº¢=å‰ ç»¿=å·¦ è“=å³ é»„=åº•</span>
        </div>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script type="module">
        import { VideoSegmenter } from './video_segmenter.js';
        import { SceneRender } from './scene_render.js';

        const statusEl = document.getElementById('status');
        const btnEdit = document.getElementById('btnEdit');
        const editorModal = document.getElementById('editorModal');
        const regionCanvas = document.getElementById('regionCanvas');
        const ctx = regionCanvas.getContext('2d', { willReadFrequently: true });
        const handles = Array.from({ length: 8 }, (_, i) => document.getElementById(`h${i}`));

        const renderer = new SceneRender('renderCanvas');
        const segmenter = new VideoSegmenter();

        renderer.init().then(() => {
            statusEl.innerText = "3D åœºæ™¯å°±ç»ªï¼Œè¯·é€‰æ‹©è§†é¢‘æº";
        }).catch(console.error);

        // ==================== 8ç‚¹é€è§†é€‰æ‹©å™¨ ====================
        const selector = {
            videoElement: null,
            activeHandleIdx: -1,
            animationId: null,

            // 8ä¸ªé€è§†ç‚¹ (å½’ä¸€åŒ–åæ ‡)
            // å¸ƒå±€ç¤ºæ„:
            //   4 -------- 5     (å‰æ¡†ä¸Šè¾¹)
            //   |  0 -- 1  |     (åå¢™ä¸Šè¾¹)
            //   |  2 -- 3  |     (åå¢™ä¸‹è¾¹)
            //   6 -------- 7     (å‰æ¡†ä¸‹è¾¹)
            points: [
                { x: 0.30, y: 0.25 }, { x: 0.70, y: 0.25 }, // 0,1 åå¢™ä¸Š
                { x: 0.30, y: 0.75 }, { x: 0.70, y: 0.75 }, // 2,3 åå¢™ä¸‹
                { x: 0.10, y: 0.05 }, { x: 0.90, y: 0.05 }, // 4,5 å‰æ¡†ä¸Š
                { x: 0.10, y: 0.95 }, { x: 0.90, y: 0.95 }  // 6,7 å‰æ¡†ä¸‹
            ],

            // 4ä¸ªé¢çš„ç‚¹ç´¢å¼• (æŒ‰ç…§ å·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹ é¡ºæ—¶é’ˆé¡ºåº)
            // è¿™æ · DewarpProcessor å¯ä»¥æ­£ç¡®è®¡ç®—å•åº”æ€§çŸ©é˜µ
            faces: {
                'box_qian': [0, 1, 3, 2], // åå¢™/å‰é¢: 0å·¦ä¸Š,1å³ä¸Š,3å³ä¸‹,2å·¦ä¸‹
                'box_zuo': [4, 0, 2, 6],  // å·¦å¢™: 4å‰å·¦ä¸Š,0åå·¦ä¸Š,2åå·¦ä¸‹,6å‰å·¦ä¸‹
                'box_you': [1, 5, 7, 3],  // å³å¢™: 1åå³ä¸Š,5å‰å³ä¸Š,7å‰å³ä¸‹,3åå³ä¸‹
                'box_di': [2, 3, 7, 6]    // åº•é¢: 2åå·¦ä¸‹,3åå³ä¸‹,7å‰å³ä¸‹,6å‰å·¦ä¸‹
            },

            colors: {
                'box_qian': '#FF0000', // çº¢è‰²
                'box_zuo': '#00FF00',  // ç»¿è‰²
                'box_you': '#0000FF',  // è“è‰²
                'box_di': '#FFFF00'    // é»„è‰²
            },

            faceLabels: {
                'box_qian': 'å‰',
                'box_zuo': 'å·¦',
                'box_you': 'å³',
                'box_di': 'åº•'
            },

            open(video, regions) {
                this.videoElement = video;
                editorModal.style.display = 'flex';
                this.resize();
                this.updateHandles();
                this.loop();
            },

            close() {
                editorModal.style.display = 'none';
                this.videoElement = null;
                if (this.animationId) cancelAnimationFrame(this.animationId);
            },

            updateHandles() {
                handles.forEach((h, i) => {
                    h.style.left = (this.points[i].x * 100) + '%';
                    h.style.top = (this.points[i].y * 100) + '%';
                });
            },

            resize() {
                if (!this.videoElement) return;
                const aspect = this.videoElement.videoWidth / this.videoElement.videoHeight;
                if (!aspect) return;

                const containerW = editorModal.clientWidth * 0.8;
                const containerH = editorModal.clientHeight * 0.75;

                if (containerW / containerH > aspect) {
                    regionCanvas.height = containerH;
                    regionCanvas.width = containerH * aspect;
                } else {
                    regionCanvas.width = containerW;
                    regionCanvas.height = containerW / aspect;
                }
            },

            loop() {
                if (editorModal.style.display === 'none' || !this.videoElement) return;
                this.animationId = requestAnimationFrame(() => this.loop());

                const vw = regionCanvas.width;
                const vh = regionCanvas.height;
                ctx.clearRect(0, 0, vw, vh);

                ctx.drawImage(this.videoElement, 0, 0, vw, vh);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(0, 0, vw, vh);

                // ç»˜åˆ¶4ä¸ªé¢
                for (let face in this.faces) {
                    this.drawFace(face);
                }

                // ç»˜åˆ¶è¿æ¥çº¿
                this.drawConnections();
            },

            drawFace(face) {
                const indices = this.faces[face];
                const color = this.colors[face];
                const pts = indices.map(i => this.points[i]);
                const vw = regionCanvas.width, vh = regionCanvas.height;

                // åŠé€æ˜å¡«å……
                ctx.fillStyle = color + '40';
                ctx.beginPath();
                ctx.moveTo(pts[0].x * vw, pts[0].y * vh);
                for (let i = 1; i < pts.length; i++) {
                    ctx.lineTo(pts[i].x * vw, pts[i].y * vh);
                }
                ctx.closePath();
                ctx.fill();

                // è¾¹æ¡†
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // æ ‡ç­¾
                const centerX = pts.reduce((s, p) => s + p.x, 0) / 4 * vw;
                const centerY = pts.reduce((s, p) => s + p.y, 0) / 4 * vh;
                ctx.fillStyle = color;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.faceLabels[face], centerX, centerY);
            },

            drawConnections() {
                const vw = regionCanvas.width, vh = regionCanvas.height;
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);

                const connections = [[0, 4], [1, 5], [2, 6], [3, 7]];
                ctx.beginPath();
                connections.forEach(([a, b]) => {
                    ctx.moveTo(this.points[a].x * vw, this.points[a].y * vh);
                    ctx.lineTo(this.points[b].x * vw, this.points[b].y * vh);
                });
                ctx.stroke();
                ctx.setLineDash([]);
            },

            getFacePoints(face) {
                const indices = this.faces[face];
                return indices.map(i => ({ ...this.points[i] }));
            },

            save() {
                console.log("ä¿å­˜é€è§†ç‚¹:", this.points);

                // å°†4ä¸ªé¢çš„é€è§†ç‚¹ä¼ é€’ç»™ segmenter
                for (let face in this.faces) {
                    const facePoints = this.getFacePoints(face);
                    console.log(`${face} ç‚¹:`, facePoints);
                    segmenter.setPerspectivePoints(face, facePoints);
                }

                this.close();
            }
        };

        window.selector = selector;

        // ==================== äº‹ä»¶ç»‘å®š ====================

        handles.forEach((h, i) => {
            h.onmousedown = (e) => {
                e.preventDefault();
                e.stopPropagation();
                selector.activeHandleIdx = i;
            };
        });

        document.addEventListener('mousemove', (e) => {
            if (selector.activeHandleIdx < 0) return;

            const editorStage = document.getElementById('editorStage');
            const rect = editorStage.getBoundingClientRect();
            let x = (e.clientX - rect.left) / rect.width;
            let y = (e.clientY - rect.top) / rect.height;

            x = Math.max(0, Math.min(1, x));
            y = Math.max(0, Math.min(1, y));

            selector.points[selector.activeHandleIdx] = { x, y };
            selector.updateHandles();
        });

        document.addEventListener('mouseup', () => {
            selector.activeHandleIdx = -1;
        });

        window.addEventListener('resize', () => selector.resize());

        // ==================== æ¸²æŸ“å¾ªç¯ ====================

        renderer.setRenderCallback(() => {
            if (segmenter.isPlaying) {
                segmenter.processFrame();
                renderer.updateTextures(segmenter.getCanvases());
            }
        });

        // ==================== é€»è¾‘æ§åˆ¶ ====================

        function onVideoReady() {
            btnEdit.style.display = 'block';
            renderer.bindTexturesToMaterials(segmenter.getCanvases());
            segmenter.setDewarpMode(true);
        }

        document.getElementById('videoInput').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            statusEl.innerText = "åŠ è½½è§†é¢‘ä¸­...";
            segmenter.loadVideo(url).then(() => {
                onVideoReady();
                statusEl.innerText = "æ’­æ”¾ä¸­ - å¯ç‚¹å‡»[æ¡†é€‰åŒºåŸŸ]";
            });
        };

        window.startWebcam = () => {
            statusEl.innerText = "è¯·æ±‚æ‘„åƒå¤´...";
            segmenter.loadWebcam().then(() => {
                onVideoReady();
                statusEl.innerText = "ç›´æ’­ä¸­ - å¯ç‚¹å‡»[æ¡†é€‰åŒºåŸŸ]";
            });
        };

        window.openEditor = () => {
            if (!segmenter.isPlaying) return;
            selector.open(segmenter.videoElement, segmenter.getRegions());
        };

        window.toggleDewarp = (enabled) => {
            segmenter.setDewarpMode(enabled);
            console.log('é€è§†æ ¡æ­£:', enabled ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨');
        };

    </script>
</body>

</html>
===== dewarp_processor.js =====
/**
 * DewarpProcessor - é€è§†å»ç•¸å˜å¤„ç†å™¨
 * 
 * åŸºäºå•åº”æ€§çŸ©é˜µ (Homography Matrix) å®ç°é€è§†å˜æ¢
 * ä» transform5_å¤šé¢å¯¼å‡º3d.html æå–çš„æ ¸å¿ƒç®—æ³•
 */
export class DewarpProcessor {
    constructor() {
        this.tempCanvas = document.createElement('canvas');
        this.tempCtx = this.tempCanvas.getContext('2d', { willReadFrequently: true });
    }

    /**
     * è®¡ç®—å•åº”æ€§çŸ©é˜µ
     * @param {number} width - ç›®æ ‡å®½åº¦
     * @param {number} height - ç›®æ ‡é«˜åº¦
     * @param {Array} sourcePoints - æºå›¾åƒä¸Šçš„4ä¸ªç‚¹ [{x, y}, {x, y}, {x, y}, {x, y}]
     * @returns {Array|null} 9å…ƒç´ çš„å•åº”æ€§çŸ©é˜µï¼Œå¦‚æœè®¡ç®—å¤±è´¥è¿”å›null
     */
    calcHomography(width, height, sourcePoints) {
        if (!sourcePoints || sourcePoints.length !== 4) {
            console.error('éœ€è¦æä¾›4ä¸ªæºç‚¹');
            return null;
        }

        const sx = sourcePoints.map(p => p.x);
        const sy = sourcePoints.map(p => p.y);

        // ç›®æ ‡ç‚¹ï¼šçŸ©å½¢çš„å››ä¸ªè§’
        const dx = [0, width, width, 0];
        const dy = [0, 0, height, height];

        // æ„å»º8x8çº¿æ€§æ–¹ç¨‹ç»„ AÂ·h = b
        const A = [];
        const b = [];

        for (let i = 0; i < 4; i++) {
            // ä¸ºæ¯ä¸ªç‚¹å¯¹æ·»åŠ ä¸¤ä¸ªæ–¹ç¨‹
            A.push([dx[i], dy[i], 1, 0, 0, 0, -sx[i] * dx[i], -sx[i] * dy[i]]);
            A.push([0, 0, 0, dx[i], dy[i], 1, -sy[i] * dx[i], -sy[i] * dy[i]]);
            b.push(sx[i]);
            b.push(sy[i]);
        }

        // é«˜æ–¯æ¶ˆå…ƒæ³•æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„
        const solution = this._solveLinearSystem(A, b);
        if (!solution) return null;

        // è¿”å›9å…ƒç´ çŸ©é˜µ (æœ€åä¸€ä¸ªå…ƒç´ å›ºå®šä¸º1)
        return [...solution, 1];
    }

    /**
     * é«˜æ–¯æ¶ˆå…ƒæ³•æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„
     * @private
     */
    _solveLinearSystem(A, b) {
        const n = 8;

        try {
            // å‰å‘æ¶ˆå…ƒ
            for (let i = 0; i < n; i++) {
                // é€‰æ‹©ä¸»å…ƒ
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) {
                        maxRow = k;
                    }
                }

                // äº¤æ¢è¡Œ
                [A[i], A[maxRow]] = [A[maxRow], A[i]];
                [b[i], b[maxRow]] = [b[maxRow], b[i]];

                // æ¶ˆå…ƒ
                for (let j = i + 1; j < n; j++) {
                    const factor = A[j][i] / A[i][i];
                    b[j] -= factor * b[i];
                    for (let k = i; k < n; k++) {
                        A[j][k] -= factor * A[i][k];
                    }
                }
            }

            // å›ä»£æ±‚è§£
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) {
                    sum += A[i][j] * x[j];
                }
                x[i] = (b[i] - sum) / A[i][i];
            }

            return x;
        } catch (e) {
            console.error('çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£å¤±è´¥:', e);
            return null;
        }
    }

    /**
     * åº”ç”¨é€è§†å˜æ¢åˆ°å›¾åƒåŒºåŸŸ
     * @param {HTMLCanvasElement} srcCanvas - æºcanvas
     * @param {Array} srcPoints - æºå›¾åƒä¸Šçš„4ä¸ªç‚¹ï¼ˆé¡ºæ—¶é’ˆï¼šå·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹ï¼‰
     * @param {HTMLCanvasElement} dstCanvas - ç›®æ ‡canvas
     * @param {Object} fillColor - å¡«å……é¢œè‰² {r, g, b} (å¯é€‰)
     */
    warpRegion(srcCanvas, srcPoints, dstCanvas, fillColor = null) {
        if (!srcPoints || srcPoints.length !== 4) {
            console.error('éœ€è¦æä¾›4ä¸ªç‚¹');
            return;
        }

        // è®¡ç®—è¾“å‡ºå°ºå¯¸ï¼šä½¿ç”¨ç‚¹ä¹‹é—´çš„è·ç¦»
        const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
        const width = Math.max(dist(srcPoints[0], srcPoints[1]), dist(srcPoints[2], srcPoints[3])) | 0;
        const height = Math.max(dist(srcPoints[0], srcPoints[3]), dist(srcPoints[1], srcPoints[2])) | 0;

        if (width <= 0 || height <= 0) {
            console.error('æ— æ•ˆçš„åŒºåŸŸå°ºå¯¸');
            return;
        }

        // è®¾ç½®ç›®æ ‡canvaså°ºå¯¸
        dstCanvas.width = width;
        dstCanvas.height = height;

        const dstCtx = dstCanvas.getContext('2d');

        // è®¡ç®—å•åº”æ€§çŸ©é˜µ
        const H = this.calcHomography(width, height, srcPoints);
        if (!H) {
            console.error('å•åº”æ€§çŸ©é˜µè®¡ç®—å¤±è´¥');
            return;
        }

        // è·å–æºå›¾åƒæ•°æ®
        const srcCtx = srcCanvas.getContext('2d');
        const srcImageData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);

        // åˆ›å»ºç›®æ ‡å›¾åƒæ•°æ®
        const dstImageData = dstCtx.createImageData(width, height);

        // ç¡®å®šå¡«å……é¢œè‰²
        const fill = fillColor || this._getAverageColor(srcImageData);

        // åº”ç”¨é€è§†å˜æ¢
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                // ä½¿ç”¨å•åº”æ€§çŸ©é˜µè®¡ç®—æºå›¾åƒåæ ‡
                const z = H[6] * x + H[7] * y + H[8];
                const srcX = (H[0] * x + H[1] * y + H[2]) / z;
                const srcY = (H[3] * x + H[4] * y + H[5]) / z;

                const dstIdx = (y * width + x) * 4;

                // æ£€æŸ¥æºåæ ‡æ˜¯å¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
                if (srcX >= 0 && srcX < srcCanvas.width && srcY >= 0 && srcY < srcCanvas.height) {
                    const srcIdx = ((srcY | 0) * srcCanvas.width + (srcX | 0)) * 4;
                    dstImageData.data[dstIdx] = srcImageData.data[srcIdx];
                    dstImageData.data[dstIdx + 1] = srcImageData.data[srcIdx + 1];
                    dstImageData.data[dstIdx + 2] = srcImageData.data[srcIdx + 2];
                    dstImageData.data[dstIdx + 3] = srcImageData.data[srcIdx + 3];
                } else {
                    // ä½¿ç”¨å¡«å……é¢œè‰²
                    dstImageData.data[dstIdx] = fill.r;
                    dstImageData.data[dstIdx + 1] = fill.g;
                    dstImageData.data[dstIdx + 2] = fill.b;
                    dstImageData.data[dstIdx + 3] = 255;
                }
            }
        }

        dstCtx.putImageData(dstImageData, 0, 0);
    }

    /**
     * è®¡ç®—å›¾åƒå¹³å‡é¢œè‰²ï¼ˆç”¨äºå¡«å……ï¼‰
     * @private
     */
    _getAverageColor(imageData) {
        let r = 0, g = 0, b = 0, count = 0;

        // é‡‡æ ·ä»¥æé«˜æ€§èƒ½
        for (let i = 0; i < imageData.data.length; i += 40) {
            if (imageData.data[i + 3] > 0) { // alpha > 0
                r += imageData.data[i];
                g += imageData.data[i + 1];
                b += imageData.data[i + 2];
                count++;
            }
        }

        return {
            r: (r / count) | 0,
            g: (g / count) | 0,
            b: (b / count) | 0
        };
    }
}

===== region_selector.js =====
export class RegionSelector {
    constructor(containerId, onSave) {
        this.container = document.getElementById(containerId);
        this.canvas = this.container.querySelector('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.onSave = onSave; // ä¿å­˜å›è°ƒ

        this.videoElement = null; // å¼•ç”¨æºè§†é¢‘
        this.currentRegions = {}; // å½“å‰ç¼–è¾‘çš„åŒºåŸŸæ•°æ®
        this.activeFace = null;   // å½“å‰æ­£åœ¨æ¡†é€‰å“ªä¸ªé¢ (ä¾‹å¦‚ 'box_qian')

        // æ–°å¢ï¼šé€‰æ‹©æ¨¡å¼
        this.selectionMode = 'rect'; // 'rect' | 'perspective'

        // é€è§†æ¨¡å¼ç›¸å…³
        this.perspectivePoints = {}; // å­˜å‚¨æ¯ä¸ªé¢çš„8ä¸ªç‚¹ (4ä¸ªåå¢™ç‚¹ + 4ä¸ªå…³è”ç‚¹)
        this.activePoint = -1; // å½“å‰æ‹–æ‹½çš„ç‚¹ç´¢å¼• (-1è¡¨ç¤ºæ— )

        this.isDragging = false;
        this.startPos = { x: 0, y: 0 };
        this.tempRect = null; // æ­£åœ¨æ‹–æ‹½ä¸­çš„æ¡†

        // é¢œè‰²é…ç½®
        this.colors = {
            'box_qian': '#FF0000', // çº¢
            'box_zuo': '#00FF00', // ç»¿
            'box_you': '#0000FF', // è“
            'box_di': '#FFFF00', // é»„
            'box_hou': '#888888'  // ç° (é»˜è®¤ä¸ç¼–è¾‘ï¼Œä½†æ˜¾ç¤º)
        };

        this._initEvents();
    }

    /**
     * æ‰“å¼€ç¼–è¾‘å™¨
     * @param {HTMLVideoElement} video - æ­£åœ¨æ’­æ”¾çš„è§†é¢‘å…ƒç´ 
     * @param {Object} regions - å½“å‰çš„åŒºåŸŸé…ç½®
     */
    open(video, regions) {
        this.videoElement = video;
        this.currentRegions = regions;
        this.container.style.display = 'flex';
        this.resize();
        this.loop();
    }

    close() {
        this.container.style.display = 'none';
        this.videoElement = null;
    }

    // è®¾ç½®å½“å‰è¦ç”»å“ªä¸ªé¢çš„æ¡†
    setActiveFace(face) {
        this.activeFace = face;
        // åˆå§‹åŒ–é€è§†ç‚¹ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
        if (this.selectionMode === 'perspective' && !this.perspectivePoints[face]) {
            this._initDefaultPerspectivePoints(face);
        }
        // æ›´æ–°æŒ‰é’®çŠ¶æ€æ ·å¼
        document.querySelectorAll('.face-btn').forEach(btn => {
            if (btn.dataset.face === face) btn.classList.add('active');
            else btn.classList.remove('active');
        });
    }

    // è®¾ç½®é€‰æ‹©æ¨¡å¼
    setMode(mode) {
        if (mode !== 'rect' && mode !== 'perspective') {
            console.error('æ— æ•ˆçš„æ¨¡å¼:', mode);
            return;
        }
        this.selectionMode = mode;

        // åˆ‡æ¢åˆ°é€è§†æ¨¡å¼æ—¶ï¼Œä¸ºå½“å‰æ¿€æ´»çš„é¢åˆå§‹åŒ–é»˜è®¤ç‚¹
        if (mode === 'perspective' && this.activeFace && !this.perspectivePoints[this.activeFace]) {
            this._initDefaultPerspectivePoints(this.activeFace);
        }
    }

    // åˆå§‹åŒ–é»˜è®¤çš„é€è§†ç‚¹ï¼ˆåŸºäºå½“å‰çŸ©å½¢åŒºåŸŸï¼‰
    _initDefaultPerspectivePoints(face) {
        const region = this.currentRegions[face];
        if (!region) {
            // å¦‚æœæ²¡æœ‰åŒºåŸŸï¼Œä½¿ç”¨é»˜è®¤å€¼
            this.perspectivePoints[face] = [
                { x: 0.1, y: 0.1 }, { x: 0.3, y: 0.1 }, { x: 0.1, y: 0.9 }, { x: 0.3, y: 0.9 }
            ];
            return;
        }

        // åŸºäºç°æœ‰çŸ©å½¢åŒºåŸŸåˆ›å»º4ä¸ªè§’ç‚¹
        const { x, y, w, h } = region;
        this.perspectivePoints[face] = [
            { x: x, y: y },           // å·¦ä¸Š
            { x: x + w, y: y },       // å³ä¸Š
            { x: x, y: y + h },       // å·¦ä¸‹
            { x: x + w, y: y + h }    // å³ä¸‹
        ];
    }

    // è·å–é€è§†ç‚¹é…ç½®ï¼ˆç”¨äºä¿å­˜ï¼‰
    getPerspectivePoints() {
        return JSON.parse(JSON.stringify(this.perspectivePoints));
    }

    save() {
        // åœ¨é€è§†æ¨¡å¼ä¸‹ï¼ŒåŒæ—¶ä¼ é€’é€è§†ç‚¹æ•°æ®
        if (this.selectionMode === 'perspective') {
            if (this.onSave) this.onSave(this.currentRegions, this.perspectivePoints);
        } else {
            if (this.onSave) this.onSave(this.currentRegions);
        }
        this.close();
    }

    // æ¯ä¸€å¸§ç»˜åˆ¶ï¼šèƒŒæ™¯è§†é¢‘ + å·²æœ‰çš„æ¡† + æ­£åœ¨ç”»çš„æ¡†
    loop() {
        if (this.container.style.display === 'none' || !this.videoElement) return;

        requestAnimationFrame(() => this.loop());

        const vw = this.canvas.width;
        const vh = this.canvas.height;

        this.ctx.clearRect(0, 0, vw, vh);

        // 1. ç»˜åˆ¶è§†é¢‘åº•å›¾
        this.ctx.drawImage(this.videoElement, 0, 0, vw, vh);
        this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
        this.ctx.fillRect(0, 0, vw, vh); // åŠ ä¸€å±‚æš—è‰²é®ç½©ï¼Œè®©æ¡†æ›´æ˜æ˜¾

        if (this.selectionMode === 'rect') {
            // çŸ©å½¢æ¨¡å¼ï¼šç»˜åˆ¶çŸ©å½¢æ¡†
            for (let face in this.currentRegions) {
                const r = this.currentRegions[face];
                this._drawRect(r, this.colors[face] || 'white', face);
            }
            if (this.isDragging && this.tempRect) {
                this._drawRect(this.tempRect, this.colors[this.activeFace], "æ­£åœ¨æ¡†é€‰...");
            }
        } else if (this.selectionMode === 'perspective') {
            // é€è§†æ¨¡å¼ï¼šç»˜åˆ¶æ‰€æœ‰é¢çš„é€è§†ç‚¹
            for (let face in this.perspectivePoints) {
                this._drawPerspectivePoints(face);
            }
        }
    }

    _drawRect(r, color, label) {
        const x = r.x * this.canvas.width;
        const y = r.y * this.canvas.height;
        const w = r.w * this.canvas.width;
        const h = r.h * this.canvas.height;

        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 3;
        this.ctx.strokeRect(x, y, w, h);

        this.ctx.fillStyle = color;
        this.ctx.font = "14px Arial";
        this.ctx.fillText(label, x, y - 5);
        this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
        this.ctx.fillRect(x, y, w, h);
    }

    _initEvents() {
        // é¼ æ ‡æŒ‰ä¸‹
        this.canvas.addEventListener('mousedown', (e) => {
            if (!this.activeFace) return;
            const rect = this.canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / rect.width;
            const mouseY = (e.clientY - rect.top) / rect.height;

            if (this.selectionMode === 'perspective') {
                // é€è§†æ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æŸä¸ªç‚¹
                this.activePoint = this._findNearestPoint(mouseX, mouseY);
                if (this.activePoint >= 0) {
                    this.isDragging = true;
                }
            } else {
                // çŸ©å½¢æ¨¡å¼ï¼šå¼€å§‹æ‹–æ‹½çŸ©å½¢
                this.isDragging = true;
                this.startPos = { x: mouseX, y: mouseY };
            }
        });

        // é¼ æ ‡ç§»åŠ¨
        this.canvas.addEventListener('mousemove', (e) => {
            if (!this.isDragging) return;
            const rect = this.canvas.getBoundingClientRect();
            const currX = (e.clientX - rect.left) / rect.width;
            const currY = (e.clientY - rect.top) / rect.height;

            if (this.selectionMode === 'perspective') {
                // é€è§†æ¨¡å¼ï¼šç§»åŠ¨å½“å‰ç‚¹
                if (this.activePoint >= 0 && this.perspectivePoints[this.activeFace]) {
                    this.perspectivePoints[this.activeFace][this.activePoint] = { x: currX, y: currY };
                }
            } else {
                // çŸ©å½¢æ¨¡å¼ï¼šæ›´æ–°ä¸´æ—¶çŸ©å½¢
                const x = Math.min(this.startPos.x, currX);
                const y = Math.min(this.startPos.y, currY);
                const w = Math.abs(currX - this.startPos.x);
                const h = Math.abs(currY - this.startPos.y);
                this.tempRect = { x, y, w, h };
            }
        });

        // é¼ æ ‡æŠ¬èµ·
        this.canvas.addEventListener('mouseup', () => {
            if (this.selectionMode === 'rect' && this.isDragging && this.tempRect) {
                // ä¿å­˜å½“å‰æ¡†åˆ° activeFace
                this.currentRegions[this.activeFace] = { ...this.tempRect };
            }
            this.isDragging = false;
            this.tempRect = null;
            this.activePoint = -1;
        });

        window.addEventListener('resize', () => this.resize());
    }

    // æŸ¥æ‰¾æœ€è¿‘çš„é€è§†ç‚¹
    _findNearestPoint(x, y) {
        if (!this.perspectivePoints[this.activeFace]) return -1;

        const threshold = 0.03; // 3% çš„è·ç¦»é˜ˆå€¼
        const points = this.perspectivePoints[this.activeFace];

        for (let i = 0; i < points.length; i++) {
            const dist = Math.hypot(points[i].x - x, points[i].y - y);
            if (dist < threshold) return i;
        }
        return -1;
    }

    // ç»˜åˆ¶é€è§†ç‚¹å’Œè¿æ¥çº¿
    _drawPerspectivePoints(face) {
        const points = this.perspectivePoints[face];
        if (!points || points.length !== 4) return;

        const color = this.colors[face] || 'white';
        const isActive = face === this.activeFace;

        // ç»˜åˆ¶å››è¾¹å½¢è½®å»“
        this.ctx.strokeStyle = isActive ? color : 'rgba(255,255,255,0.3)';
        this.ctx.lineWidth = isActive ? 3 : 2;
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x * this.canvas.width, points[0].y * this.canvas.height);
        this.ctx.lineTo(points[1].x * this.canvas.width, points[1].y * this.canvas.height);
        this.ctx.lineTo(points[3].x * this.canvas.width, points[3].y * this.canvas.height);
        this.ctx.lineTo(points[2].x * this.canvas.width, points[2].y * this.canvas.height);
        this.ctx.closePath();
        this.ctx.stroke();

        // ç»˜åˆ¶æ§åˆ¶ç‚¹
        if (isActive) {
            points.forEach((p, i) => {
                const x = p.x * this.canvas.width;
                const y = p.y * this.canvas.height;

                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.strokeStyle = 'white';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                // æ ‡ç­¾
                this.ctx.fillStyle = 'white';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`P${i}`, x + 12, y - 12);
            });
        }
    }

    // ä¿æŒ canvas æ¯”ä¾‹ä¸è§†é¢‘ä¸€è‡´
    resize() {
        if (!this.videoElement) return;
        const aspect = this.videoElement.videoWidth / this.videoElement.videoHeight;
        if (!aspect) return;

        // ç®€å•å¤„ç†ï¼šè®© canvas å®½åº¦å æ»¡çˆ¶å®¹å™¨ 80%ï¼Œé«˜åº¦è‡ªé€‚åº”
        const containerW = this.container.clientWidth * 0.8;
        const containerH = this.container.clientHeight * 0.8;

        if (containerW / containerH > aspect) {
            this.canvas.height = containerH;
            this.canvas.width = containerH * aspect;
        } else {
            this.canvas.width = containerW;
            this.canvas.height = containerW / aspect;
        }
    }
}
===== scene_render.js =====
export class SceneRender {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        // ç¦æ­¢æµè§ˆå™¨åŠ«æŒæ»šè½®
        this.canvas.addEventListener("wheel", (evt) => evt.preventDefault(), { passive: false });

        this.engine = null;
        this.scene = null;
        this.materialsMap = null;
        this.dynamicTextures = {};
        this.onRender = null;

        // ç¡¬ç¼–ç æ¨¡å‹è·¯å¾„ (è¯·ç¡®ä¿è¯¥æ–‡ä»¶åœ¨åŒä¸€ç›®å½•ä¸‹ï¼Œä¸”é€šè¿‡ Local Server è®¿é—®)
        this.modelPath = "./Untitled5.glb";
    }

    async init() {
        this.engine = new BABYLON.Engine(this.canvas, true);
        this.scene = new BABYLON.Scene(this.engine);
        this.scene.clearColor = new BABYLON.Color4(0.08, 0.08, 0.1, 1);

        this._setupCamera();
        this._setupLight();
        this._initMaterialsConfig(); // åŠ è½½ä½ çš„æ—‹è½¬é…ç½®

        await this._loadModel();

        this.engine.runRenderLoop(() => {
            this.scene.render();
            if (this.onRender) this.onRender();
        });

        window.addEventListener("resize", () => this.engine.resize());
    }

    setRenderCallback(callback) {
        this.onRender = callback;
    }

    _setupCamera() {
        const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 10, new BABYLON.Vector3(0, 0, 0), this.scene);
        camera.attachControl(this.canvas, true);
        camera.wheelPrecision = 30;
        camera.minZ = 0.1;
    }

    _setupLight() {
        const hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), this.scene);
        hemiLight.intensity = 0.8;
        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), this.scene);
        dirLight.intensity = 0.5;
    }

    // === è¿™é‡Œä¸¥æ ¼ç…§æ¬äº†ä½ ä¹‹å‰çš„æˆåŠŸé…ç½® ===
    _initMaterialsConfig() {
        this.materialsMap = {
            'box_qian': { name: 'box_qian', matObject: null, config: { wAng: Math.PI / 2, uScale: -1, vScale: 1 } },
            'box_hou': { name: 'box_hou', matObject: null, config: { wAng: 0, uScale: -1, vScale: 1 } },
            'box_zuo': { name: 'box_zuo', matObject: null, config: { wAng: Math.PI, uScale: -1, vScale: 1 } },
            'box_you': { name: 'box_you', matObject: null, config: { wAng: Math.PI / 2, uScale: -1, vScale: 1 } },
            'box_di': { name: 'box_di', matObject: null, config: { wAng: 0, uScale: -1, vScale: 1 } }
        };
    }

    async _loadModel() {
        try {
            const result = await BABYLON.SceneLoader.ImportMeshAsync("", this.modelPath, "", this.scene, null, ".glb");
            const root = result.meshes[0];
            root.normalizeToUnitCube();

            // 1. ç»‘å®šæè´¨
            for (let key in this.materialsMap) {
                const targetName = this.materialsMap[key].name;
                const foundMat = this.scene.getMaterialByName(targetName);
                if (foundMat) {
                    this.materialsMap[key].matObject = foundMat;
                    foundMat.roughness = 1.0;
                    foundMat.metallic = 0.0;
                    foundMat.albedoColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                }
            }

            // 2. ä¸¥æ ¼ç…§æ¬ä¹‹å‰çš„æ™ºèƒ½ UV ä¿®å¤é€»è¾‘
            result.meshes.forEach(m => {
                if (m.material && m.material.name === this.materialsMap['box_di'].name) {
                    this._fixFloorUVsSmart(m);
                }
            });

        } catch (e) {
            console.error(e);
            alert("æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥è·¯å¾„æˆ–ç¡®ä¿ä½¿ç”¨äº†æœ¬åœ°æœåŠ¡å™¨(localhost)");
        }
    }

    bindTexturesToMaterials(canvasMap) {
        for (let key in this.materialsMap) {
            const target = this.materialsMap[key];
            if (!target.matObject || !canvasMap[key]) continue;

            if (target.matObject.albedoTexture) target.matObject.albedoTexture.dispose();
            if (this.dynamicTextures[key]) this.dynamicTextures[key].dispose();

            const canvas = canvasMap[key];
            const texture = new BABYLON.DynamicTexture(`tex_${key}`, canvas, this.scene, true);

            // === æ ¸å¿ƒä¿®å¤ï¼šå¼ºåˆ¶è®¾ç½®çº¹ç†åŒ…è£¹æ¨¡å¼ä¸º REPEAT ===
            // ä¹‹å‰çš„ VideoTexture é»˜è®¤å¯èƒ½æ˜¯ Repeatï¼Œä½† DynamicTexture é»˜è®¤å¯èƒ½æ˜¯ Clamp
            // å½“ uScale ä¸º -1 æ—¶ï¼ŒClamp ä¼šå¯¼è‡´è¾¹ç¼˜åƒç´ è¢«æ‹‰ä¼¸æˆæ¡çº¹ï¼ŒRepeat åˆ™ä¼šæ­£å¸¸ç¿»è½¬ã€‚
            texture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE; // 1 = WRAP (Repeat)
            texture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE; // 1 = WRAP (Repeat)
            // ===========================================

            // åº”ç”¨ä¹‹å‰çš„é…ç½®
            const conf = target.config;
            texture.uRotationCenter = 0.5;
            texture.vRotationCenter = 0.5;
            texture.wAng = conf.wAng;
            texture.uScale = conf.uScale;
            texture.vScale = conf.vScale;

            target.matObject.albedoTexture = texture;
            target.matObject.emissiveTexture = texture;
            target.matObject.emissiveColor = new BABYLON.Color3(1, 1, 1);

            this.dynamicTextures[key] = texture;
        }
    }

    updateTextures(canvasMap) {
        for (let key in this.dynamicTextures) {
            // å‚æ•° false è¡¨ç¤ºä¸åè½¬ Y è½´ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ config é‡Œé€šè¿‡ scale æ§åˆ¶äº†æ–¹å‘
            this.dynamicTextures[key].update(false);
        }
    }

    // === ä¸¥æ ¼ç…§æ¬ä¹‹å‰çš„æ™ºèƒ½ UV ç®—æ³• ===
    _fixFloorUVsSmart(floorMesh) {
        let meshQian = null, meshHou = null;
        this.scene.meshes.forEach(m => {
            if (m.material && m.material.name === 'box_qian') meshQian = m;
            if (m.material && m.material.name === 'box_hou') meshHou = m;
        });
        if (!meshQian || !meshHou) return;

        const centerQian = meshQian.getBoundingInfo().boundingBox.centerWorld;
        const centerHou = meshHou.getBoundingInfo().boundingBox.centerWorld;
        const positions = floorMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
        if (!positions) return;

        let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
        for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i], z = positions[i + 2];
            if (x < minX) minX = x; if (x > maxX) maxX = x;
            if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
        }
        const rangeX = maxX - minX || 1;
        const rangeZ = maxZ - minZ || 1;
        const diffX = centerQian.x - centerHou.x;
        const diffZ = centerQian.z - centerHou.z;
        const isAlignedZ = Math.abs(diffZ) > Math.abs(diffX);

        const uvs = [];
        for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i], z = positions[i + 2];
            let u, v;
            if (isAlignedZ) {
                u = (x - minX) / rangeX;
                if (diffZ > 0) v = (z - minZ) / rangeZ;
                else v = 1.0 - ((z - minZ) / rangeZ);
            } else {
                u = (z - minZ) / rangeZ;
                if (diffX > 0) v = (x - minX) / rangeX;
                else v = 1.0 - ((x - minX) / rangeX);
            }
            uvs.push(u, v);
        }
        floorMesh.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs);
    }
}
===== video_segmenter.js =====
import { DewarpProcessor } from './dewarp_processor.js';

export class VideoSegmenter {
    constructor() {
        this.videoElement = document.createElement('video');
        this.videoElement.muted = true;
        this.videoElement.playsInline = true;
        this.videoElement.loop = true;
        this.videoElement.crossOrigin = "anonymous";
        this.videoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');

        this.isPlaying = false;

        // 5ä¸ªé¢ï¼Œä½† hou ä¿æŒç©ºç™½
        this.faces = ['box_qian', 'box_hou', 'box_zuo', 'box_you', 'box_di'];

        // éœ€è¦æ¸²æŸ“çš„4ä¸ªé¢
        this.activeFaces = ['box_qian', 'box_zuo', 'box_you', 'box_di'];

        this.channels = {};
        this.contexts = {};

        this.faces.forEach(face => {
            const c = document.createElement('canvas');
            c.width = 512;
            c.height = 512;
            this.channels[face] = c;
            this.contexts[face] = c.getContext('2d', { willReadFrequently: true });
        });

        // box_hou å¡«å……é»‘è‰²
        const houCtx = this.contexts['box_hou'];
        houCtx.fillStyle = '#000000';
        houCtx.fillRect(0, 0, 512, 512);

        // é»˜è®¤åŒºåŸŸ (å…¼å®¹ç”¨)
        this.regions = {
            'box_qian': { x: 0.0, y: 0.0, w: 0.25, h: 1.0 },
            'box_hou': { x: 0.0, y: 0.0, w: 0.0, h: 0.0 },
            'box_zuo': { x: 0.25, y: 0.0, w: 0.25, h: 1.0 },
            'box_you': { x: 0.5, y: 0.0, w: 0.25, h: 1.0 },
            'box_di': { x: 0.75, y: 0.0, w: 0.25, h: 1.0 }
        };

        // é€è§†å»ç•¸å˜å¤„ç†å™¨
        this.dewarpProcessor = new DewarpProcessor();
        this.useDewarp = true;

        // å­˜å‚¨æ¯ä¸ªé¢çš„4ä¸ªé€è§†ç‚¹ (å½’ä¸€åŒ–åæ ‡)
        this.perspectivePoints = {};

        // ç”¨äºå¤„ç†çš„ä¸´æ—¶canvas
        this.tempCanvas = document.createElement('canvas');
        this.tempCtx = this.tempCanvas.getContext('2d', { willReadFrequently: true });
    }

    async loadVideo(url) {
        this.videoElement.src = url;
        await this.videoElement.play();
        this.isPlaying = true;
    }

    async loadWebcam() {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
        this.videoElement.srcObject = stream;
        await this.videoElement.play();
        this.isPlaying = true;
    }

    processFrame() {
        if (!this.isPlaying || this.videoElement.paused || this.videoElement.ended) return;

        const vw = this.videoElement.videoWidth;
        const vh = this.videoElement.videoHeight;
        if (!vw || !vh) return;

        // å…ˆå°†è§†é¢‘ç»˜åˆ¶åˆ°ä¸´æ—¶canvas
        this.tempCanvas.width = vw;
        this.tempCanvas.height = vh;
        this.tempCtx.drawImage(this.videoElement, 0, 0, vw, vh);

        // åªå¤„ç†4ä¸ªæ´»è·ƒçš„é¢
        this.activeFaces.forEach(face => {
            const ctx = this.contexts[face];
            const cvs = this.channels[face];

            if (this.useDewarp && this.perspectivePoints[face] && this.perspectivePoints[face].length === 4) {
                // é€è§†ç‚¹é¡ºåºè½¬æ¢ï¼š
                // è¾“å…¥: [å·¦ä¸Š, å³ä¸Š, å·¦ä¸‹, å³ä¸‹] (ç´¢å¼• 0,1,2,3)
                // DewarpProcessoréœ€è¦: [å·¦ä¸Š, å³ä¸Š, å³ä¸‹, å·¦ä¸‹] (é¡ºæ—¶é’ˆ)
                const pts = this.perspectivePoints[face];
                const srcPoints = [
                    { x: pts[0].x * vw, y: pts[0].y * vh }, // å·¦ä¸Š -> å·¦ä¸Š
                    { x: pts[1].x * vw, y: pts[1].y * vh }, // å³ä¸Š -> å³ä¸Š
                    { x: pts[3].x * vw, y: pts[3].y * vh }, // å³ä¸‹ (ç´¢å¼•3) -> å³ä¸‹
                    { x: pts[2].x * vw, y: pts[2].y * vh }  // å·¦ä¸‹ (ç´¢å¼•2) -> å·¦ä¸‹
                ];

                this.dewarpProcessor.warpRegion(this.tempCanvas, srcPoints, cvs);
            } else {
                const r = this.regions[face];
                if (r && r.w > 0 && r.h > 0) {
                    ctx.drawImage(
                        this.videoElement,
                        r.x * vw, r.y * vh, r.w * vw, r.h * vh,
                        0, 0, cvs.width, cvs.height
                    );
                }
            }
        });
    }

    getCanvases() {
        return this.channels;
    }

    setRegion(face, region) {
        if (this.regions[face]) {
            this.regions[face] = region;
        }
    }

    getRegions() {
        return JSON.parse(JSON.stringify(this.regions));
    }

    setDewarpMode(enabled) {
        this.useDewarp = enabled;
    }

    setPerspectivePoints(face, points) {
        if (points && points.length === 4) {
            this.perspectivePoints[face] = points;
            console.log(`è®¾ç½® ${face} é€è§†ç‚¹:`, points);
        }
    }

    getPerspectivePoints() {
        return JSON.parse(JSON.stringify(this.perspectivePoints));
    }
}
