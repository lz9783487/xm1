<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¤šé¢é€è§†å˜æ¢ (8ç‚¹åˆ‡4é¢)</title>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #f4f7f6; display: flex; flex-direction: column; align-items: center; padding: 20px; color: #333; }
        h2 { margin-bottom: 20px; }
        .controls { margin-bottom: 25px; display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); z-index: 100; }
        button, .btn-label { padding: 10px 24px; font-size: 14px; font-weight: 600; border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; display: inline-flex; align-items: center; justify-content: center; }
        .btn-primary { background: #007bff; color: white; }
        .btn-primary:hover { background: #0069d9; transform: translateY(-1px); }
        input[type="file"] { display: none; }
        
        .workspace { display: flex; flex-direction: column; gap: 40px; align-items: center; width: 100%; max-width: 1200px; padding: 20px; }
        .canvas-wrapper { display: flex; flex-direction: column; align-items: center; }
        .canvas-title { margin-bottom: 10px; font-weight: 600; color: #555; font-size: 18px;}
        
        /* ç¼–è¾‘åŒºæ ·å¼ */
        .editor-stage {
             /* å…è®¸å†…å®¹æº¢å‡ºï¼Œä»¥ä¾¿èƒ½æŠŠç‚¹æ‹–åˆ°å¤–é¢ */
            overflow: visible; 
            position: relative; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.1); 
            background: white; 
            border-radius: 8px; 
            line-height: 0; 
            user-select: none; 
            touch-action: none; 
            margin: 30px; /* å¢åŠ å¤–è¾¹è·ï¼Œé˜²æ­¢ç‚¹æ‹–å‡ºå»è¢«é®æŒ¡ */
        }
        canvas { display: block; max-width: 100%; height: auto; }
        
        /* æ‹–æ‹½ç‚¹æ ·å¼ */
        .handle {
            width: 20px; height: 20px;
            background: rgba(255, 69, 0, 0.9);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8), 0 2px 4px rgba(0,0,0,0.3);
            border-radius: 50%; position: absolute;
            transform: translate(-50%, -50%); cursor: grab; z-index: 20;
        }
        .handle:hover { transform: translate(-50%, -50%) scale(1.2); background: rgba(255, 69, 0, 1); }
        .handle:active { cursor: grabbing; transform: translate(-50%, -50%) scale(1.0); background: red; }
        /* ç»™å‰åç‚¹åŠ ä¸€ç‚¹é¢œè‰²åŒºåˆ† */
        .handle.front { background: rgba(0, 150, 255, 0.9); }
        .handle.front:hover { background: rgba(0, 150, 255, 1); }

        /* ç»“æœå±•ç¤ºåŒº Grid å¸ƒå±€ */
        #resultsGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            width: 100%;
            display: none; /* åˆå§‹éšè— */
        }
        .result-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .result-card h4 { margin: 0 0 10px 0; color: #666; }
        .result-canvas-container { border: 1px solid #eee; }

    </style>
</head>
<body>

    <h2>å¤šé¢é€è§†å˜æ¢ (8ç‚¹åˆ‡4é¢)</h2>

    <div class="controls">
        <label for="upload" class="btn-label btn-primary">ğŸ“ 1. å¯¼å…¥å›¾ç‰‡</label>
        <input type="file" id="upload" accept="image/*">
        <button onclick="performMultiTransform()" class="btn-primary">ğŸ”„ 2. æ‰§è¡Œå¤šé¢å˜æ¢</button>
    </div>

    <div class="workspace">
        <div class="canvas-wrapper">
            <div class="canvas-title">åŸå›¾ç¼–è¾‘ (æ‹–æ‹½8ä¸ªé¡¶ç‚¹å®šä½ç©ºé—´)</div>
            <div class="editor-stage" id="editorContainer">
                <canvas id="srcCanvas"></canvas>
                <div class="handle back" id="p0" title="å-ä¸Šå·¦"></div> 
                <div class="handle back" id="p1" title="å-ä¸Šå³"></div> 
                <div class="handle back" id="p2" title="å-ä¸‹å·¦"></div> 
                <div class="handle back" id="p3" title="å-ä¸‹å³"></div>
                <div class="handle front" id="p4" title="å‰-ä¸Šå·¦"></div> 
                <div class="handle front" id="p5" title="å‰-ä¸Šå³"></div> 
                <div class="handle front" id="p6" title="å‰-ä¸‹å·¦"></div> 
                <div class="handle front" id="p7" title="å‰-ä¸‹å³"></div>
            </div>
        </div>

        <div id="resultsGrid">
            <div class="result-card">
                <h4>1. åå¢™é¢ (Back)</h4>
                <div class="result-canvas-container"><canvas id="resCanvasBack"></canvas></div>
            </div>
            <div class="result-card">
                <h4>2. å·¦å¢™é¢ (Left)</h4>
                <div class="result-canvas-container"><canvas id="resCanvasLeft"></canvas></div>
            </div>
            <div class="result-card">
                <h4>3. å³å¢™é¢ (Right)</h4>
                <div class="result-canvas-container"><canvas id="resCanvasRight"></canvas></div>
            </div>
            <div class="result-card">
                <h4>4. åœ°é¢ (Bottom)</h4>
                <div class="result-canvas-container"><canvas id="resCanvasBottom"></canvas></div>
            </div>
        </div>
    </div>
<script>
    // --- æ ¸å¿ƒçŠ¶æ€ä¸é…ç½® ---
    const srcCanvas = document.getElementById('srcCanvas');
    const ctxSrc = srcCanvas.getContext('2d', { willReadFrequently: true });
    const editorContainer = document.getElementById('editorContainer');
    
    // è·å–8ä¸ªæ§åˆ¶ç‚¹çš„ DOM å…ƒç´ 
    const handleElements = Array.from({length: 8}, (_, i) => document.getElementById(`p${i}`));
    
    // ç»“æœç”»å¸ƒå¼•ç”¨
    const resCanvases = {
        back: document.getElementById('resCanvasBack'),
        left: document.getElementById('resCanvasLeft'),
        right: document.getElementById('resCanvasRight'),
        bottom: document.getElementById('resCanvasBottom')
    };

    let img = new Image();
    let points = Array(8).fill().map(() => ({x:0, y:0}));
    let activePointIndex = -1;
    let srcImageDataGlobal = null; // å…¨å±€ç¼“å­˜åŸå›¾æ•°æ®

    // =================================================================
    // å…³é”®é…ç½®ï¼šå®šä¹‰é¢ä¸ç‚¹çš„å¯¹åº”å…³ç³»
    // çº¦å®šç‚¹çš„é¡ºåºå¿…é¡»æ˜¯ï¼š[å·¦ä¸Š, å³ä¸Š, å³ä¸‹, å·¦ä¸‹] (Top-Left, Top-Right, Bottom-Right, Bottom-Left)
    // ç´¢å¼•å¯¹åº”å…³ç³»: 0:åä¸Šå·¦, 1:åä¸Šå³, 2:åä¸‹å·¦, 3:åä¸‹å³, 4:å‰ä¸Šå·¦, 5:å‰ä¸Šå³, 6:å‰ä¸‹å·¦, 7:å‰ä¸‹å³
    // =================================================================
    const facesConfig = {
        back:   [0, 1, 3, 2], // åå¢™
        left:   [4, 0, 2, 6], // å·¦å¢™ (å‰ä¸Šå·¦ -> åä¸Šå·¦ -> åä¸‹å·¦ -> å‰ä¸‹å·¦)
        right:  [1, 5, 7, 3], // å³å¢™ (åä¸Šå³ -> å‰ä¸Šå³ -> å‰ä¸‹å³ -> åä¸‹å³)
        bottom: [2, 3, 7, 6]  // åœ°é¢ (åä¸‹å·¦ -> åä¸‹å³ -> å‰ä¸‹å³ -> å‰ä¸‹å·¦)
    };

    // --- 1. åˆå§‹åŒ–ä¸å›¾ç‰‡åŠ è½½ ---
    document.getElementById('upload').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (event) => { img.src = event.target.result; };
        img.onload = () => { initWorkspace(); };
        reader.readAsDataURL(file);
    });

    function initWorkspace() {
        srcCanvas.width = img.width;
        srcCanvas.height = img.height;
        
        // ã€ä¿®å¤ç‚¹ã€‘ï¼šå¿…é¡»å…ˆç”»å›¾ï¼Œå†è·å–æ•°æ®ï¼
        // 1. å…ˆæŠŠçº¯å‡€çš„å›¾ç‰‡ç”»ä¸Šå»
        ctxSrc.drawImage(img, 0, 0);
        
        // 2. æ­¤æ—¶è·å–æ‰æ˜¯çœŸæ­£çš„å›¾ç‰‡æ•°æ®ï¼ˆä¸åŒ…å«çº¢è‰²çš„çº¿æ¡†ï¼‰
        srcImageDataGlobal = ctxSrc.getImageData(0, 0, srcCanvas.width, srcCanvas.height);
        
        // 3. åˆå§‹åŒ–ç‚¹çš„ä½ç½®ï¼ˆå¦‚æœå°šæœªåˆå§‹åŒ–ï¼‰
        // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡åŠ è½½ï¼Œæˆ–è€…æƒ³è¦é‡ç½®ç‚¹ä½ç½®ï¼Œæ‰§è¡Œä»¥ä¸‹é€»è¾‘
        // è¿™é‡Œç®€å•åˆ¤æ–­ï¼šå¦‚æœæ‰€æœ‰ç‚¹éƒ½åœ¨(0,0)ï¼Œè¯´æ˜æ˜¯ç¬¬ä¸€æ¬¡
        if (points[0].x === 0 && points[0].y === 0) {
            const w = srcCanvas.width, h = srcCanvas.height;
            const cx = w / 2, cy = h / 2;
            const backW = w * 0.4, backH = h * 0.4;
            points[0] = { x: cx - backW/2, y: cy - backH/2 }; 
            points[1] = { x: cx + backW/2, y: cy - backH/2 }; 
            points[2] = { x: cx - backW/2, y: cy + backH/2 }; 
            points[3] = { x: cx + backW/2, y: cy + backH/2 }; 
            
            const frontW = w * 0.8, frontH = h * 0.8;
            points[4] = { x: cx - frontW/2, y: cy - frontH/2 }; 
            points[5] = { x: cx + frontW/2, y: cy - frontH/2 }; 
            points[6] = { x: cx - frontW/2, y: cy + frontH/2 }; 
            points[7] = { x: cx + frontW/2, y: cy + frontH/2 }; 
        }

        drawEditor();
        document.getElementById('resultsGrid').style.display = 'none';
    }

	// ç»˜åˆ¶ç¼–è¾‘åŒºåŸŸ
    function drawEditor() {
        ctxSrc.clearRect(0, 0, srcCanvas.width, srcCanvas.height);
        // èƒŒæ™¯å›¾
        ctxSrc.drawImage(img, 0, 0);
        
        // ç»˜åˆ¶è¾…åŠ©çº¿
        ctxSrc.lineWidth = 2;
        ctxSrc.strokeStyle = 'rgba(0, 255, 255, 0.7)'; 
        ctxSrc.beginPath();
        
        // 1. åå¹³é¢ (Back Face): é—­åˆçŸ©å½¢
        drawPolygon([0, 1, 3, 2]);
        
        // 2. æ£± (Connecting Lines): è¿æ¥å‰åå¹³é¢çš„å››è§’
        ctxSrc.moveTo(points[0].x, points[0].y); ctxSrc.lineTo(points[4].x, points[4].y); // åä¸Šå·¦ -> å‰ä¸Šå·¦
        ctxSrc.moveTo(points[1].x, points[1].y); ctxSrc.lineTo(points[5].x, points[5].y); // åä¸Šå³ -> å‰ä¸Šå³
        ctxSrc.moveTo(points[2].x, points[2].y); ctxSrc.lineTo(points[6].x, points[6].y); // åä¸‹å·¦ -> å‰ä¸‹å·¦
        ctxSrc.moveTo(points[3].x, points[3].y); ctxSrc.lineTo(points[7].x, points[7].y); // åä¸‹å³ -> å‰ä¸‹å³

        // 3. å‰å¹³é¢ (Front Face): åªç”» å·¦ã€å³ã€ä¸‹ ä¸‰æ¡è¾¹ï¼Œé¡¶éƒ¨å¼€å£
        // å·¦è¾¹ (å‰ä¸Šå·¦ -> å‰ä¸‹å·¦)
        ctxSrc.moveTo(points[4].x, points[4].y); ctxSrc.lineTo(points[6].x, points[6].y);
        // å³è¾¹ (å‰ä¸Šå³ -> å‰ä¸‹å³)
        ctxSrc.moveTo(points[5].x, points[5].y); ctxSrc.lineTo(points[7].x, points[7].y);
        // ä¸‹è¾¹ (å‰ä¸‹å·¦ -> å‰ä¸‹å³)
        ctxSrc.moveTo(points[6].x, points[6].y); ctxSrc.lineTo(points[7].x, points[7].y);
        
        // ã€å·²ç§»é™¤ã€‘é¡¶éƒ¨è¿çº¿ (points[4] -> points[5]) ä¸å†ç»˜åˆ¶

        ctxSrc.stroke();

        // æ›´æ–°ç‚¹ä½ç½®
        points.forEach((p, i) => {
            handleElements[i].style.left = (p.x / srcCanvas.width * 100) + '%';
            handleElements[i].style.top = (p.y / srcCanvas.height * 100) + '%';
        });
    }

    function drawPolygon(indices) {
        ctxSrc.moveTo(points[indices[0]].x, points[indices[0]].y);
        for (let i = 1; i < indices.length; i++) {
            ctxSrc.lineTo(points[indices[i]].x, points[indices[i]].y);
        }
        ctxSrc.closePath();
    }

    // --- 2. äº¤äº’äº‹ä»¶å¤„ç† ---
    function getEventPositionInCanvas(e) {
        const rect = srcCanvas.getBoundingClientRect();
        const clientX = e.touches && e.touches.length > 0 ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches && e.touches.length > 0 ? e.touches[0].clientY : e.clientY;
        const scaleX = srcCanvas.width / rect.width;
        const scaleY = srcCanvas.height / rect.height;
        return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
    }

    handleElements.forEach((h, index) => {
        const startDrag = (e) => {
            e.preventDefault(); e.stopPropagation();
            activePointIndex = index;
        };
        h.addEventListener('mousedown', startDrag);
        h.addEventListener('touchstart', startDrag, { passive: false });
    });

    const moveHandler = (e) => {
        if (activePointIndex !== -1) {
            e.preventDefault();
            const pos = getEventPositionInCanvas(e);
            points[activePointIndex].x = pos.x;
            points[activePointIndex].y = pos.y;
            drawEditor();
        }
    };
    const endHandler = () => { activePointIndex = -1; };

    window.addEventListener('mousemove', moveHandler);
    window.addEventListener('touchmove', moveHandler, { passive: false });
    window.addEventListener('mouseup', endHandler);
    window.addEventListener('touchend', endHandler);

    // --- 3. æ ¸å¿ƒç®—æ³•ï¼šæ‰§è¡Œå¤šé¢å˜æ¢ ---
    
    function performMultiTransform() {
        if (!srcImageDataGlobal) return alert("è¯·å…ˆå¯¼å…¥å›¾ç‰‡");
        
        // è®¡ç®—å¹³å‡è‰² (ç”¨äºå¡«å……ç©ºç™½)
        const avgColor = getAverageColor(srcImageDataGlobal);
        
        document.getElementById('resultsGrid').style.display = 'grid';

        for (const [faceName, pointIndices] of Object.entries(facesConfig)) {
            const targetCanvas = resCanvases[faceName];
            if (targetCanvas) {
                const facePoints = pointIndices.map(idx => points[idx]);
                warpSingleFace(facePoints, targetCanvas, srcImageDataGlobal, srcCanvas.width, srcCanvas.height, avgColor);
            }
        }
    }

    function warpSingleFace(facePoints, dstCanvas, srcImageData, srcW, srcH, fillColor) {
        const ctxDst = dstCanvas.getContext('2d');
        const srcData = srcImageData.data;

        // 1. ä¼°ç®—å°ºå¯¸
        const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        const wTop = dist(facePoints[0], facePoints[1]);
        const wBottom = dist(facePoints[3], facePoints[2]);
        const hLeft = dist(facePoints[0], facePoints[3]);
        const hRight = dist(facePoints[1], facePoints[2]);
        
        let outW = Math.round(Math.max(wTop, wBottom));
        let outH = Math.round(Math.max(hLeft, hRight));
        
        // é™åˆ¶æœ€å¤§å°ºå¯¸é˜²æ­¢å¡é¡¿
        const maxDim = 1000;
        const scale = Math.min(1, maxDim / Math.max(outW, outH));
        outW = Math.max(1, Math.round(outW * scale));
        outH = Math.max(1, Math.round(outH * scale));

        dstCanvas.width = outW;
        dstCanvas.height = outH;

        const dstImageData = ctxDst.createImageData(outW, outH);
        const dstData = dstImageData.data;

        // 2. è®¡ç®—çŸ©é˜µï¼šTarget(è§„åˆ™çŸ©å½¢) -> Source(æ‰­æ›²å››è¾¹å½¢)
        // è¿™æ ·æˆ‘ä»¬åœ¨éå† Target çš„åƒç´ æ—¶ï¼Œå¯ä»¥é€šè¿‡çŸ©é˜µæ‰¾åˆ° Source ä¸Šå¯¹åº”çš„ç‚¹
        const targetRect = [{x:0,y:0}, {x:outW,y:0}, {x:outW,y:outH}, {x:0,y:outH}];
        const H = calcHomography(targetRect, facePoints);
        
        if (!H) return;

        // 3. åƒç´ éå†
        for (let v = 0; v < outH; v++) {
            for (let u = 0; u < outW; u++) {
                const denom = H[6]*u + H[7]*v + H[8];
                if (Math.abs(denom) < 1e-10) continue;

                const x_src = (H[0]*u + H[1]*v + H[2]) / denom;
                const y_src = (H[3]*u + H[4]*v + H[5]) / denom;

                const x = Math.round(x_src);
                const y = Math.round(y_src);
                
                const dstIdx = (v * outW + u) * 4;

                if (x >= 0 && x < srcW && y >= 0 && y < srcH) {
                    const srcIdx = (y * srcW + x) * 4;
                    dstData[dstIdx]     = srcData[srcIdx];     
                    dstData[dstIdx + 1] = srcData[srcIdx + 1]; 
                    dstData[dstIdx + 2] = srcData[srcIdx + 2]; 
                    dstData[dstIdx + 3] = 255;                 
                } else {
                    // å¡«å……å¹³å‡è‰²
                    dstData[dstIdx]     = fillColor.r;
                    dstData[dstIdx + 1] = fillColor.g;
                    dstData[dstIdx + 2] = fillColor.b;
                    dstData[dstIdx + 3] = 255; 
                }
            }
        }
        ctxDst.putImageData(dstImageData, 0, 0);
    }

    function getAverageColor(imgData) {
        const data = imgData.data;
        let r=0, g=0, b=0, count=0;
        const step = 40; 
        for (let i = 0; i < data.length; i += 4 * step) {
            // å¿½ç•¥å®Œå…¨é€æ˜çš„åƒç´ 
            if (data[i+3] > 0) {
                r += data[i]; g += data[i+1]; b += data[i+2]; count++;
            }
        }
        // å¦‚æœå…¨æ˜¯é»‘/é€æ˜ï¼Œå°±è¿”å›é»˜è®¤ç°è‰²ï¼Œè€Œä¸æ˜¯é»‘è‰²
        return count > 0 ? { r: r/count|0, g: g/count|0, b: b/count|0 } : {r:50,g:50,b:50};
    }

    function calcHomography(src, dst) {
        let x0 = src[0].x, y0 = src[0].y, u0 = dst[0].x, v0 = dst[0].y;
        let x1 = src[1].x, y1 = src[1].y, u1 = dst[1].x, v1 = dst[1].y;
        let x2 = src[2].x, y2 = src[2].y, u2 = dst[2].x, v2 = dst[2].y;
        let x3 = src[3].x, y3 = src[3].y, u3 = dst[3].x, v3 = dst[3].y;

        let A = [
            [x0, y0, 1, 0, 0, 0, -u0*x0, -u0*y0],
            [0, 0, 0, x0, y0, 1, -v0*x0, -v0*y0],
            [x1, y1, 1, 0, 0, 0, -u1*x1, -u1*y1],
            [0, 0, 0, x1, y1, 1, -v1*x1, -v1*y1],
            [x2, y2, 1, 0, 0, 0, -u2*x2, -u2*y2],
            [0, 0, 0, x2, y2, 1, -v2*x2, -v2*y2],
            [x3, y3, 1, 0, 0, 0, -u3*x3, -u3*y3],
            [0, 0, 0, x3, y3, 1, -v3*x3, -v3*y3]
        ];
        let B = [u0, v0, u1, v1, u2, v2, u3, v3];

        const n = 8;
        for (let i = 0; i < n; i++) {
            let maxRow = i;
            for (let k = i + 1; k < n; k++) {
                if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
            }
            [A[i], A[maxRow]] = [A[maxRow], A[i]];
            [B[i], B[maxRow]] = [B[maxRow], B[i]];

            let pivot = A[i][i];
            if (Math.abs(pivot) < 1e-8) return null; 

            for (let j = i; j < n; j++) A[i][j] /= pivot;
            B[i] /= pivot;

            for (let k = 0; k < n; k++) {
                if (k !== i) {
                    let factor = A[k][i];
                    for (let j = i; j < n; j++) A[k][j] -= factor * A[i][j];
                    B[k] -= factor * B[i];
                }
            }
        }
        return [...B, 1];
    }
</script>
</body>
</html>