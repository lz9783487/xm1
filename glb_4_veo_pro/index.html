<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ¨¡å‹è§†é¢‘æ˜ å°„ (8ç‚¹é€è§†æ¡†é€‰)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            font-family: sans-serif;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
        }

        .ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: #eee;
            border: 1px solid #444;
            backdrop-filter: blur(5px);
        }

        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 5px;
            font-size: 12px;
        }

        button:hover {
            background: #005bb5;
        }

        .status {
            margin-top: 10px;
            font-size: 12px;
            color: #00ff99;
        }

        #editorModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .toolbar {
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            background: #222;
            padding: 10px;
            border-radius: 8px;
            justify-content: center;
        }

        .toolbar span {
            color: #00ff99;
            line-height: 30px;
            margin-right: 10px;
        }

        #regionCanvas {
            border: 2px solid #333;
            cursor: crosshair;
            background: #000;
        }

        .handle {
            width: 18px;
            height: 18px;
            background: rgba(255, 69, 0, 0.9);
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            cursor: grab;
            z-index: 20;
        }

        .handle.front {
            background: rgba(0, 150, 255, 0.9);
        }

        .handle::after {
            content: attr(data-label);
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 11px;
            white-space: nowrap;
        }

        .editor-container {
            position: relative;
            line-height: 0;
            user-select: none;
        }

        .legend {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
            text-align: center;
        }

        .legend span {
            margin: 0 10px;
        }

        .legend .back-color {
            color: #FF4500;
        }

        .legend .front-color {
            color: #0096FF;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>

<body>

    <div class="ui-layer">
        <h3 style="margin-top:0">æ§åˆ¶å°</h3>
        <div>
            <input type="file" id="videoInput" accept="video/*" style="display:none">
            <button onclick="document.getElementById('videoInput').click()">ğŸ“‚ åŠ è½½æœ¬åœ°è§†é¢‘</button>
            <button onclick="startWebcam()">ğŸ“· ä½¿ç”¨æ‘„åƒå¤´</button>
        </div>
        <div style="margin-top: 10px; border-top: 1px solid #444; padding-top: 10px;">
            <div style="margin-bottom: 10px;">
                <label style="color: #ccc;">
                    <input type="checkbox" id="enableDewarp" checked onchange="toggleDewarp(this.checked)">
                    å¯ç”¨é€è§†æ ¡æ­£
                </label>
            </div>
            <button onclick="openEditor()" id="btnEdit" style="background: #e65c00; width: 100%; display:none">âœï¸
                æ¡†é€‰åŒºåŸŸ (8ç‚¹)</button>
        </div>
        <div id="status" class="status">æ­£åœ¨åˆå§‹åŒ–...</div>
    </div>

    <div id="editorModal">
        <div class="toolbar">
            <span>æ‹–åŠ¨8ä¸ªæ§åˆ¶ç‚¹è°ƒæ•´é€è§†åŒºåŸŸ</span>
            <button onclick="selector.save()" style="background: #00cc66;">âœ… å®Œæˆå¹¶åº”ç”¨</button>
            <button onclick="selector.close()" style="background: #666;">âŒ å–æ¶ˆ</button>
        </div>
        <div class="editor-container" id="editorStage">
            <canvas id="regionCanvas"></canvas>
            <!-- 8ä¸ªæ‹–æ‹½ç‚¹: 0-3å†…æ¡†(åå¢™), 4-7å¤–æ¡†(å‰æ¡†) -->
            <div class="handle back" id="h0" data-label="åå·¦ä¸Š"></div>
            <div class="handle back" id="h1" data-label="åå³ä¸Š"></div>
            <div class="handle back" id="h2" data-label="åå·¦ä¸‹"></div>
            <div class="handle back" id="h3" data-label="åå³ä¸‹"></div>
            <div class="handle front" id="h4" data-label="å‰å·¦ä¸Š"></div>
            <div class="handle front" id="h5" data-label="å‰å³ä¸Š"></div>
            <div class="handle front" id="h6" data-label="å‰å·¦ä¸‹"></div>
            <div class="handle front" id="h7" data-label="å‰å³ä¸‹"></div>
        </div>
        <div class="legend">
            <span class="back-color">â— å†…æ¡†(åå¢™/å‰é¢)</span>
            <span class="front-color">â— å¤–æ¡†(å‰æ¡†)</span>
            <span>| çº¢=å‰ ç»¿=å·¦ è“=å³ é»„=åº•</span>
        </div>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script type="module">
        import { VideoSegmenter } from './video_segmenter.js';
        import { SceneRender } from './scene_render.js';

        const statusEl = document.getElementById('status');
        const btnEdit = document.getElementById('btnEdit');
        const editorModal = document.getElementById('editorModal');
        const regionCanvas = document.getElementById('regionCanvas');
        const ctx = regionCanvas.getContext('2d', { willReadFrequently: true });
        const handles = Array.from({ length: 8 }, (_, i) => document.getElementById(`h${i}`));

        const renderer = new SceneRender('renderCanvas');
        const segmenter = new VideoSegmenter();

        renderer.init().then(() => {
            statusEl.innerText = "3D åœºæ™¯å°±ç»ªï¼Œè¯·é€‰æ‹©è§†é¢‘æº";
        }).catch(console.error);

        // ==================== 8ç‚¹é€è§†é€‰æ‹©å™¨ ====================
        const selector = {
            videoElement: null,
            activeHandleIdx: -1,
            animationId: null,

            // 8ä¸ªé€è§†ç‚¹ (å½’ä¸€åŒ–åæ ‡)
            // å¸ƒå±€ç¤ºæ„:
            //   4 -------- 5     (å‰æ¡†ä¸Šè¾¹)
            //   |  0 -- 1  |     (åå¢™ä¸Šè¾¹)
            //   |  2 -- 3  |     (åå¢™ä¸‹è¾¹)
            //   6 -------- 7     (å‰æ¡†ä¸‹è¾¹)
            points: [
                { x: 0.30, y: 0.25 }, { x: 0.70, y: 0.25 }, // 0,1 åå¢™ä¸Š
                { x: 0.30, y: 0.75 }, { x: 0.70, y: 0.75 }, // 2,3 åå¢™ä¸‹
                { x: 0.10, y: 0.05 }, { x: 0.90, y: 0.05 }, // 4,5 å‰æ¡†ä¸Š
                { x: 0.10, y: 0.95 }, { x: 0.90, y: 0.95 }  // 6,7 å‰æ¡†ä¸‹
            ],

            // 4ä¸ªé¢çš„ç‚¹ç´¢å¼• (æŒ‰ç…§ å·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹ é¡ºæ—¶é’ˆé¡ºåº)
            // è¿™æ · DewarpProcessor å¯ä»¥æ­£ç¡®è®¡ç®—å•åº”æ€§çŸ©é˜µ
            faces: {
                'box_qian': [0, 1, 3, 2], // åå¢™/å‰é¢: 0å·¦ä¸Š,1å³ä¸Š,3å³ä¸‹,2å·¦ä¸‹
                'box_zuo': [1, 5, 7, 3],  // å·¦å¢™ (Swapped with Right)
                'box_you': [4, 0, 2, 6],  // å³å¢™ (Swapped with Left)
                'box_di': [2, 3, 7, 6]    // åº•é¢: 2åå·¦ä¸‹,3åå³ä¸‹,7å‰å³ä¸‹,6å‰å·¦ä¸‹
            },

            colors: {
                'box_qian': '#FF0000', // çº¢è‰²
                'box_zuo': '#00FF00',  // ç»¿è‰²
                'box_you': '#0000FF',  // è“è‰²
                'box_di': '#FFFF00'    // é»„è‰²
            },

            faceLabels: {
                'box_qian': 'å‰',
                'box_zuo': 'å·¦',
                'box_you': 'å³',
                'box_di': 'åº•'
            },

            open(video, regions) {
                this.videoElement = video;
                editorModal.style.display = 'flex';
                this.resize();
                this.updateHandles();
                this.loop();
            },

            close() {
                editorModal.style.display = 'none';
                this.videoElement = null;
                if (this.animationId) cancelAnimationFrame(this.animationId);
            },

            updateHandles() {
                handles.forEach((h, i) => {
                    h.style.left = (this.points[i].x * 100) + '%';
                    h.style.top = (this.points[i].y * 100) + '%';
                });
            },

            resize() {
                if (!this.videoElement) return;
                const vw = this.videoElement.videoWidth || this.videoElement.width;
                const vh = this.videoElement.videoHeight || this.videoElement.height;
                const aspect = vw / vh;
                if (!aspect) return;

                const containerW = editorModal.clientWidth * 0.8;
                const containerH = editorModal.clientHeight * 0.75;

                if (containerW / containerH > aspect) {
                    regionCanvas.height = containerH;
                    regionCanvas.width = containerH * aspect;
                } else {
                    regionCanvas.width = containerW;
                    regionCanvas.height = containerW / aspect;
                }
            },

            loop() {
                if (editorModal.style.display === 'none' || !this.videoElement) return;
                this.animationId = requestAnimationFrame(() => this.loop());

                const vw = regionCanvas.width;
                const vh = regionCanvas.height;
                ctx.clearRect(0, 0, vw, vh);

                ctx.drawImage(this.videoElement, 0, 0, vw, vh);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(0, 0, vw, vh);

                // ç»˜åˆ¶4ä¸ªé¢
                for (let face in this.faces) {
                    this.drawFace(face);
                }

                // ç»˜åˆ¶è¿æ¥çº¿
                this.drawConnections();
            },

            drawFace(face) {
                const indices = this.faces[face];
                const color = this.colors[face];
                const pts = indices.map(i => this.points[i]);
                const vw = regionCanvas.width, vh = regionCanvas.height;

                // åŠé€æ˜å¡«å……
                ctx.fillStyle = color + '40';
                ctx.beginPath();
                ctx.moveTo(pts[0].x * vw, pts[0].y * vh);
                for (let i = 1; i < pts.length; i++) {
                    ctx.lineTo(pts[i].x * vw, pts[i].y * vh);
                }
                ctx.closePath();
                ctx.fill();

                // è¾¹æ¡†
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // æ ‡ç­¾
                const centerX = pts.reduce((s, p) => s + p.x, 0) / 4 * vw;
                const centerY = pts.reduce((s, p) => s + p.y, 0) / 4 * vh;
                ctx.fillStyle = color;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.faceLabels[face], centerX, centerY);
            },

            drawConnections() {
                const vw = regionCanvas.width, vh = regionCanvas.height;
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);

                const connections = [[0, 4], [1, 5], [2, 6], [3, 7]];
                ctx.beginPath();
                connections.forEach(([a, b]) => {
                    ctx.moveTo(this.points[a].x * vw, this.points[a].y * vh);
                    ctx.lineTo(this.points[b].x * vw, this.points[b].y * vh);
                });
                ctx.stroke();
                ctx.setLineDash([]);
            },

            getFacePoints(face) {
                const indices = this.faces[face];
                return indices.map(i => ({ ...this.points[i] }));
            },

            save() {
                console.log("ä¿å­˜é€è§†ç‚¹:", this.points);

                // å°†4ä¸ªé¢çš„é€è§†ç‚¹ä¼ é€’ç»™ segmenter
                for (let face in this.faces) {
                    const facePoints = this.getFacePoints(face);
                    console.log(`${face} ç‚¹:`, facePoints);
                    segmenter.setPerspectivePoints(face, facePoints);
                }

                this.close();
            }
        };

        window.selector = selector;

        // ==================== äº‹ä»¶ç»‘å®š ====================

        handles.forEach((h, i) => {
            h.onmousedown = (e) => {
                e.preventDefault();
                e.stopPropagation();
                selector.activeHandleIdx = i;
            };
        });

        document.addEventListener('mousemove', (e) => {
            if (selector.activeHandleIdx < 0) return;

            const editorStage = document.getElementById('editorStage');
            const rect = editorStage.getBoundingClientRect();
            let x = (e.clientX - rect.left) / rect.width;
            let y = (e.clientY - rect.top) / rect.height;

            x = Math.max(0, Math.min(1, x));
            y = Math.max(0, Math.min(1, y));

            selector.points[selector.activeHandleIdx] = { x, y };
            selector.updateHandles();
        });

        document.addEventListener('mouseup', () => {
            selector.activeHandleIdx = -1;
        });

        window.addEventListener('resize', () => selector.resize());

        // ==================== æ¸²æŸ“å¾ªç¯ ====================

        renderer.setRenderCallback(() => {
            if (segmenter.isPlaying) {
                segmenter.processFrame();
                renderer.updateTextures(segmenter.getCanvases());
            }
        });

        // ==================== é€»è¾‘æ§åˆ¶ ====================

        function onVideoReady() {
            btnEdit.style.display = 'block';
            renderer.bindTexturesToMaterials(segmenter.getCanvases());
            segmenter.setDewarpMode(true);
        }

        document.getElementById('videoInput').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            statusEl.innerText = "åŠ è½½è§†é¢‘ä¸­...";
            segmenter.loadVideo(url).then(() => {
                onVideoReady();
                statusEl.innerText = "æ’­æ”¾ä¸­ - å¯ç‚¹å‡»[æ¡†é€‰åŒºåŸŸ]";
            });
        };

        window.startWebcam = () => {
            statusEl.innerText = "è¯·æ±‚æ‘„åƒå¤´...";
            segmenter.loadWebcam().then(() => {
                onVideoReady();
                statusEl.innerText = "ç›´æ’­ä¸­ - å¯ç‚¹å‡»[æ¡†é€‰åŒºåŸŸ]";
            });
        };

        window.openEditor = () => {
            if (!segmenter.isPlaying) return;
            // ä½¿ç”¨ getSource() è·å–å¤„ç†åçš„ç”»é¢ (Canvas)
            selector.open(segmenter.getSource(), segmenter.getRegions());
        };

        window.toggleDewarp = (enabled) => {
            segmenter.setDewarpMode(enabled);
            console.log('é€è§†æ ¡æ­£:', enabled ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨');
        };

    </script>
</body>

</html>