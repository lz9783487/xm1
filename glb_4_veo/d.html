<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ¨¡å‹äº”é¢ç‹¬ç«‹è§†é¢‘æ’­æ”¾ (æ”¯æŒé»˜è®¤è·¯å¾„)</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #111;
            font-family: 'Segoe UI', sans-serif;
        }

        #renderCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
            z-index: 1;
        }

        .controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100;
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(8px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            box-sizing: border-box;
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
            min-width: 80px;
        }

        .control-group label {
            font-size: 11px;
            color: #bbb;
            font-weight: 600;
        }

        .btn-file {
            position: relative;
            overflow: hidden;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px 12px;
            cursor: pointer;
            font-size: 12px;
            color: #eee;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn-file:hover {
            background: #444;
            border-color: #888;
            transform: translateY(-1px);
        }

        .btn-file input[type=file] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
        }

        .btn-blue {
            background: #0066cc;
            border-color: #005bb5;
            color: white;
        }

        .divider {
            width: 1px;
            height: 35px;
            background: rgba(255, 255, 255, 0.15);
            margin: 0 5px;
        }

        .status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 50;
            color: #00ff99;
            font-size: 13px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 4px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div class="controls">
        <div class="control-group">
            <label>1. æ¨¡å‹ (GLB)</label>
            <div class="btn-file btn-blue">ğŸ“¦ å¯¼å…¥/æ›¿æ¢<input type="file" id="fileGLB" accept=".glb,.gltf"></div>
        </div>
        <div class="divider"></div>
        <div class="control-group"><label>å‰ (qian)</label>
            <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_qian" accept="video/*">
            </div>
        </div>
        <div class="control-group"><label>å (hou)</label>
            <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_hou" accept="video/*">
            </div>
        </div>
        <div class="control-group"><label>å·¦ (zuo)</label>
            <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_zuo" accept="video/*">
            </div>
        </div>
        <div class="control-group"><label>å³ (you)</label>
            <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_you" accept="video/*">
            </div>
        </div>
        <div class="control-group"><label>åº• (di)</label>
            <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_di" accept="video/*"></div>
        </div>
    </div>

    <div id="status" class="status">æ­£åœ¨æ£€æŸ¥é»˜è®¤æ¨¡å‹...</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        // === é…ç½®é¡¹ ===
        const DEFAULT_MODEL_PATH = "/Users/lz/Desktop/xm1/glb/Untitled5.glb"; // ç¡¬ç¼–ç è·¯å¾„ï¼šè¯·ç¡®ä¿åŒç›®å½•ä¸‹æœ‰è¿™ä¸ªæ–‡ä»¶

        const canvas = document.getElementById("renderCanvas");
        canvas.addEventListener("wheel", (evt) => evt.preventDefault(), { passive: false });

        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.08, 0.08, 0.1, 1);

        const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 10, new BABYLON.Vector3(0, 0, 0), scene);
        camera.attachControl(canvas, true);
        camera.wheelPrecision = 30; camera.minZ = 0.1;

        const hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
        hemiLight.intensity = 0.8;
        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
        dirLight.intensity = 0.5;

        // æè´¨é…ç½®è¡¨ (wAng: æ—‹è½¬, uScale/vScale: é•œåƒ)
        let materialsMap = {
            'box_qian': { name: 'box_qian', matObject: null, texture: null, config: { wAng: Math.PI / 2, uScale: -1, vScale: 1 } },
            'box_hou': { name: 'box_hou', matObject: null, texture: null, config: { wAng: 0, uScale: -1, vScale: 1 } },
            'box_zuo': { name: 'box_zuo', matObject: null, texture: null, config: { wAng: Math.PI, uScale: -1, vScale: 1 } },
            'box_you': { name: 'box_you', matObject: null, texture: null, config: { wAng: Math.PI / 2, uScale: -1, vScale: 1 } },
            'box_di': { name: 'box_di', matObject: null, texture: null, config: { wAng: 0, uScale: -1, vScale: 1 } }
        };

        // === æ ¸å¿ƒä¿®æ”¹ï¼šå°è£…é€šç”¨çš„åŠ è½½å‡½æ•° ===
        function loadModel(url, isDefault = false) {
            // å¦‚æœåœºæ™¯é‡Œå·²ç»æœ‰æ¨¡å‹äº†ï¼Œå…ˆæ¸…ç†æ‰ï¼ˆé™¤äº†ç›¸æœºå’Œå…‰ç…§ï¼‰
            // è¿™é‡Œç®€å•å¤„ç†ï¼šdisposeæ‰€æœ‰meshï¼Œå®é™…é¡¹ç›®ä¸­å¯èƒ½éœ€è¦æ›´ç»†è‡´çš„æ¸…ç†
            if (scene.meshes.length > 0) {
                // è¿‡æ»¤æ‰éå¯¼å…¥çš„mesh(å¦‚æœæœ‰çš„è¯)ï¼Œæˆ–è€…ç›´æ¥ç®€å•ç²—æš´ä¿ç•™ç›¸æœº
                const meshesToKeep = [];
                for (let m of scene.meshes) {
                    // ç®€å•æ¸…ç†é€»è¾‘ï¼šæ¸…ç†ä¹‹å‰çš„å¯¼å…¥
                    if (m.name !== "__root__") m.dispose();
                }
            }

            document.getElementById('status').innerText = isDefault ? "å°è¯•åŠ è½½é»˜è®¤æ¨¡å‹..." : "åŠ è½½æ¨¡å‹ä¸­...";

            // å¼€å§‹åŠ è½½
            BABYLON.SceneLoader.ImportMeshAsync("", url, "", scene, null, ".glb").then((result) => {
                const root = result.meshes[0];
                root.normalizeToUnitCube();

                document.getElementById('status').innerText = "æ¨¡å‹åŠ è½½æˆåŠŸï¼Œè¯·ä¸Šä¼ è§†é¢‘";

                // ç»‘å®šæè´¨å¯¹è±¡
                for (let key in materialsMap) {
                    const targetName = materialsMap[key].name;
                    const foundMat = scene.getMaterialByName(targetName);
                    if (foundMat) {
                        materialsMap[key].matObject = foundMat;
                        foundMat.roughness = 1.0;
                        foundMat.metallic = 0.0;
                        foundMat.albedoColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                    }
                }

                // ä¿®å¤åº•é¢ UV
                result.meshes.forEach(m => {
                    if (m.material && m.material.name === materialsMap['box_di'].name) {
                        fixFloorUVsSmart(m, scene);
                    }
                });

            }).catch((err) => {
                console.warn(err);
                if (isDefault) {
                    document.getElementById('status').innerText = "æœªæ‰¾åˆ°é»˜è®¤æ¨¡å‹ (model.glb)ï¼Œè¯·æ‰‹åŠ¨å¯¼å…¥";
                } else {
                    document.getElementById('status').innerText = "æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶";
                }
            });
        }

        // === 1. åˆå§‹åŒ–æ—¶å°è¯•åŠ è½½é»˜è®¤æ¨¡å‹ ===
        // æ³¨æ„ï¼šWebæµè§ˆå™¨å®‰å…¨é™åˆ¶ï¼ŒåŠ è½½æœ¬åœ°æ–‡ä»¶é€šå¸¸éœ€è¦ç®€å•çš„ HTTP æœåŠ¡å™¨ (å¦‚ VSCode Live Server)
        // å¦‚æœç›´æ¥åŒå‡» html æ‰“å¼€ï¼ŒåŠ è½½æœ¬åœ°è·¯å¾„å¯èƒ½ä¼šæŠ¥ CORS é”™è¯¯æˆ– 404
        loadModel(DEFAULT_MODEL_PATH, true);

        // === 2. æ‰‹åŠ¨å¯¼å…¥æŒ‰é’® (è¦†ç›–é»˜è®¤) ===
        document.getElementById('fileGLB').onchange = (evt) => {
            const file = evt.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            loadModel(url, false);
        };

        // === 3. è§†é¢‘å¤„ç†é€»è¾‘ (ä¿æŒä¸å˜) ===
        document.querySelectorAll('.video-input').forEach(input => {
            input.onchange = (evt) => {
                const file = evt.target.files[0];
                const face = evt.target.dataset.face;
                if (!file || !materialsMap[face].matObject) return;
                applyVideoToFace(face, URL.createObjectURL(file));
            };
        });

        function applyVideoToFace(faceKey, videoUrl) {
            const target = materialsMap[faceKey];
            if (!target.matObject) return;
            if (target.texture) target.texture.dispose();

            const videoTexture = new BABYLON.VideoTexture(
                `vid_${faceKey}`, videoUrl, scene, true, false,
                BABYLON.Texture.TRILINEAR_SAMPLINGMODE,
                { autoPlay: true, loop: true, muted: true }
            );

            videoTexture.uRotationCenter = 0.5;
            videoTexture.vRotationCenter = 0.5;
            const conf = target.config;
            videoTexture.wAng = conf.wAng;
            videoTexture.uScale = conf.uScale;
            videoTexture.vScale = conf.vScale;

            target.matObject.albedoTexture = videoTexture;
            target.matObject.emissiveTexture = videoTexture;
            target.matObject.emissiveColor = new BABYLON.Color3(1, 1, 1);
            target.texture = videoTexture;
        }

        // === 4. æ™ºèƒ½UVé€»è¾‘ (ä¿æŒä¸å˜) ===
        function fixFloorUVsSmart(floorMesh, scene) {
            let meshQian = null, meshHou = null;
            scene.meshes.forEach(m => {
                if (m.material && m.material.name === 'box_qian') meshQian = m;
                if (m.material && m.material.name === 'box_hou') meshHou = m;
            });
            if (!meshQian || !meshHou) { console.warn("æ— æ³•å®šä½å‰åï¼Œä½¿ç”¨é»˜è®¤UV"); return; }

            const centerQian = meshQian.getBoundingInfo().boundingBox.centerWorld;
            const centerHou = meshHou.getBoundingInfo().boundingBox.centerWorld;
            const positions = floorMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            if (!positions) return;

            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i], z = positions[i + 2];
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
            }
            const rangeX = maxX - minX || 1;
            const rangeZ = maxZ - minZ || 1;
            const diffX = centerQian.x - centerHou.x;
            const diffZ = centerQian.z - centerHou.z;
            const isAlignedZ = Math.abs(diffZ) > Math.abs(diffX);

            const uvs = [];
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i], z = positions[i + 2];
                let u, v;
                if (isAlignedZ) {
                    u = (x - minX) / rangeX;
                    if (diffZ > 0) v = (z - minZ) / rangeZ;
                    else v = 1.0 - ((z - minZ) / rangeZ);
                } else {
                    u = (z - minZ) / rangeZ;
                    if (diffX > 0) v = (x - minX) / rangeX;
                    else v = 1.0 - ((x - minX) / rangeX);
                }
                uvs.push(u, v);
            }
            floorMesh.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs);
        }

        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());
    </script>
</body>

</html>