<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ¨¡å‹äº”é¢ç‹¬ç«‹è§†é¢‘æ’­æ”¾ (æ™ºèƒ½åº•é¢å®šå‘)</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #111;
            font-family: 'Segoe UI', sans-serif;
        }

        #renderCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
            z-index: 1;
        }

        /* æ§åˆ¶é¢æ¿ */
        .controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100;
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(8px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            box-sizing: border-box;
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
            min-width: 80px;
        }

        .control-group label {
            font-size: 11px;
            color: #bbb;
            font-weight: 600;
        }

        /* æŒ‰é’®æ ·å¼ */
        .btn-file {
            position: relative;
            overflow: hidden;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px 12px;
            cursor: pointer;
            font-size: 12px;
            color: #eee;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn-file:hover {
            background: #444;
            border-color: #888;
            transform: translateY(-1px);
        }

        .btn-file input[type=file] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
        }

        .btn-blue {
            background: #0066cc;
            border-color: #005bb5;
            color: white;
        }

        .divider {
            width: 1px;
            height: 35px;
            background: rgba(255, 255, 255, 0.15);
            margin: 0 5px;
        }

        .status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 50;
            color: #00ff99;
            font-size: 13px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 4px;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>

<body>

    <div class="controls">
        <div class="control-group">
            <label>1. æ¨¡å‹ (GLB)</label>
            <div class="btn-file btn-blue">
                ğŸ“¦ å¯¼å…¥
                <input type="file" id="fileGLB" accept=".glb,.gltf">
            </div>
        </div>
        <div class="divider"></div>
        <div class="control-group"><label>å‰ (qian)</label>
            <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_qian" accept="video/*">
            </div>
        </div>
        <div class="control-group"><label>å (hou)</label>
            <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_hou" accept="video/*">
            </div>
        </div>
        <div class="control-group"><label>å·¦ (zuo)</label>
            <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_zuo" accept="video/*">
            </div>
        </div>
        <div class="control-group"><label>å³ (you)</label>
            <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_you" accept="video/*">
            </div>
        </div>
        <div class="control-group"><label>åº• (di)</label>
            <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_di" accept="video/*"></div>
        </div>
    </div>

    <div id="status" class="status">ç­‰å¾…å¯¼å…¥ GLB æ¨¡å‹...</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");

        // é˜»æ­¢é»˜è®¤æ»šåŠ¨è¡Œä¸ºï¼ˆæ”¾å¤§æ¨¡å‹ä¸æ”¾å¤§é¡µé¢ï¼‰
        canvas.addEventListener("wheel", (evt) => evt.preventDefault(), { passive: false });

        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.08, 0.08, 0.1, 1);

        const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 10, new BABYLON.Vector3(0, 0, 0), scene);
        camera.attachControl(canvas, true);
        camera.wheelPrecision = 30; camera.minZ = 0.1;

        const hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
        hemiLight.intensity = 0.8;
        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
        dirLight.intensity = 0.5;

        // æè´¨æ˜ å°„è¡¨ (ç§»é™¤äº† rotation å­—æ®µï¼Œå› ä¸ºä¸å†æ‰‹åŠ¨æ§åˆ¶)
        let materialsMap = {
            'box_qian': { name: 'box_qian', matObject: null, texture: null },
            'box_hou': { name: 'box_hou', matObject: null, texture: null },
            'box_zuo': { name: 'box_zuo', matObject: null, texture: null },
            'box_you': { name: 'box_you', matObject: null, texture: null },
            'box_di': { name: 'box_di', matObject: null, texture: null }
        };

        // === 2. åŠ è½½æ¨¡å‹ ===
        document.getElementById('fileGLB').onchange = (evt) => {
            const file = evt.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            document.getElementById('status').innerText = "åŠ è½½æ¨¡å‹ä¸­...";

            BABYLON.SceneLoader.ImportMeshAsync("", url, "", scene, null, ".glb").then((result) => {
                const root = result.meshes[0];
                root.normalizeToUnitCube();
                document.getElementById('status').innerText = "æ¨¡å‹å°±ç»ªï¼Œè¯·ä¸Šä¼ è§†é¢‘";

                // 2.1 ç»‘å®šæè´¨
                let foundCount = 0;
                for (let key in materialsMap) {
                    const targetName = materialsMap[key].name;
                    const foundMat = scene.getMaterialByName(targetName);
                    if (foundMat) {
                        materialsMap[key].matObject = foundMat;
                        foundMat.roughness = 1.0;
                        foundMat.metallic = 0.0;
                        foundMat.albedoColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                        foundCount++;
                    }
                }

                // 2.2 æ™ºèƒ½ä¿®å¤åº•é¢ UV
                // æˆ‘ä»¬éœ€è¦ä¼ å…¥ scene å¯¹è±¡æ¥æŸ¥æ‰¾ qian å’Œ hou
                result.meshes.forEach(m => {
                    if (m.material && m.material.name === materialsMap['box_di'].name) {
                        fixFloorUVsSmart(m, scene);
                    }
                });

                document.getElementById('status').innerText = `åŠ è½½å®Œæˆ (${foundCount}/5 ä¸ªé¢)`;
            }).catch(console.error);
        };

        // === 3. è§†é¢‘ä¸Šä¼  ===
        document.querySelectorAll('.video-input').forEach(input => {
            input.onchange = (evt) => {
                const file = evt.target.files[0];
                const face = evt.target.dataset.face;
                if (!file || !materialsMap[face].matObject) return;
                applyVideoToFace(face, URL.createObjectURL(file));
            };
        });

        function applyVideoToFace(faceKey, videoUrl) {
            const target = materialsMap[faceKey];
            if (!target.matObject) return;
            if (target.texture) target.texture.dispose();

            const videoTexture = new BABYLON.VideoTexture(
                `vid_${faceKey}`, videoUrl, scene, true, false,
                BABYLON.Texture.TRILINEAR_SAMPLINGMODE,
                { autoPlay: true, loop: true, muted: true }
            );

            // === æ ¸å¿ƒæ–¹å‘æ§åˆ¶ ===
            // ä¾§é¢ï¼švScale = -1 è§£å†³å€’ç½®é—®é¢˜
            // åº•é¢ï¼švScale = 1ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ fixFloorUVsSmart é‡Œæ‰‹åŠ¨è®¡ç®—å¥½äº†æ–¹å‘
            if (faceKey === 'box_di') {
                videoTexture.uScale = 1;
                videoTexture.vScale = 1;
                videoTexture.wAng = 0; // æ— éœ€æ—‹è½¬ï¼ŒUV å·²ç»å¯¹äº†
            } else {
                videoTexture.uScale = 1;
                videoTexture.vScale = -1; // ä¾§é¢ç¿»è½¬
                videoTexture.wAng = 0;    // ç§»é™¤ä¹‹å‰çš„æ—‹è½¬é€»è¾‘
            }

            target.matObject.albedoTexture = videoTexture;
            target.matObject.emissiveTexture = videoTexture;
            target.matObject.emissiveColor = new BABYLON.Color3(1, 1, 1);
            target.texture = videoTexture;
        }

        // === 4. æ™ºèƒ½åº•é¢ UV ç®—æ³• ===
        // æ ¹æ® box_qian å’Œ box_hou çš„ä½ç½®å†³å®š UV æ–¹å‘
        function fixFloorUVsSmart(floorMesh, scene) {
            // 1. å°è¯•åœ¨åœºæ™¯ä¸­æ‰¾åˆ° box_qian å’Œ box_hou çš„ç½‘æ ¼
            // æ³¨æ„ï¼šè¿™é‡Œå‡è®¾ç½‘æ ¼åç§°åŒ…å«äº†å…³é”®å­—ï¼Œæˆ–è€…ä½ æ˜ç¡®çŸ¥é“ç½‘æ ¼å
            // è¿™é‡Œæˆ‘ä»¬ç”¨ä¸€ç§æ¨¡ç³ŠåŒ¹é…æ–¹æ³•ï¼Œæ‰¾åˆ°ä½¿ç”¨å¯¹åº”æè´¨çš„ç½‘æ ¼
            let meshQian = null;
            let meshHou = null;

            scene.meshes.forEach(m => {
                if (m.material && m.material.name === 'box_qian') meshQian = m;
                if (m.material && m.material.name === 'box_hou') meshHou = m;
            });

            if (!meshQian || !meshHou) {
                console.warn("æ— æ³•æ‰¾åˆ° box_qian æˆ– box_houï¼Œåº•é¢å°†ä½¿ç”¨é»˜è®¤ UV");
                // å¦‚æœæ‰¾ä¸åˆ°ï¼Œå°±ç”¨æ™®é€šçš„é“ºæ»¡é€»è¾‘
                fixFloorUVsDefault(floorMesh);
                return;
            }

            // 2. è·å–å®ƒä»¬çš„ä¸–ç•Œåæ ‡ä¸­å¿ƒ
            // ä½¿ç”¨ BoundingBox ä¸­å¿ƒæ¯” position æ›´ç¨³å¥
            const centerQian = meshQian.getBoundingInfo().boundingBox.centerWorld;
            const centerHou = meshHou.getBoundingInfo().boundingBox.centerWorld;

            console.log("Qian Center:", centerQian);
            console.log("Hou Center:", centerHou);

            // 3. è®¡ç®—åº•é¢çš„é¡¶ç‚¹èŒƒå›´
            const positions = floorMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            if (!positions) return;

            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 2];
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
            }
            const rangeX = maxX - minX || 1;
            const rangeZ = maxZ - minZ || 1;

            // 4. åˆ¤æ–­æ–¹å‘è½´
            // è®¡ç®— Qian å’Œ Hou åœ¨ Xè½´ å’Œ Zè½´ ä¸Šçš„è·ç¦»å·®
            const diffX = centerQian.x - centerHou.x;
            const diffZ = centerQian.z - centerHou.z;

            // åˆ¤æ–­æ¨¡å‹ä¸»è¦æ˜¯æ²¿ç€ Zè½´ è¿˜æ˜¯ Xè½´ æ’åˆ—çš„
            const isAlignedZ = Math.abs(diffZ) > Math.abs(diffX);

            // 5. ç”Ÿæˆ UV
            // ç›®æ ‡ï¼šè§†é¢‘ä¸Šä¾§ (V=1) è´´ç€ Qianï¼Œä¸‹ä¾§ (V=0) è´´ç€ Hou
            const uvs = [];

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 2];

                let u, v;

                if (isAlignedZ) {
                    // ä¸»è½´æ˜¯ Z
                    // U è½´é€šå¸¸å¯¹åº” X
                    u = (x - minX) / rangeX;

                    if (diffZ > 0) {
                        // Qian åœ¨ +Z æ–¹å‘ (MaxZ)
                        // æˆ‘ä»¬éœ€è¦ V=1 åœ¨ MaxZï¼ŒV=0 åœ¨ MinZ
                        v = (z - minZ) / rangeZ;
                    } else {
                        // Qian åœ¨ -Z æ–¹å‘ (MinZ)
                        // æˆ‘ä»¬éœ€è¦ V=1 åœ¨ MinZï¼ŒV=0 åœ¨ MaxZ
                        v = 1.0 - ((z - minZ) / rangeZ);
                    }
                } else {
                    // ä¸»è½´æ˜¯ X (æ¨¡å‹å¯èƒ½è¢«æ—‹è½¬äº†90åº¦)
                    // è¿™ç§æƒ…å†µä¸‹ï¼ŒZ å˜æˆäº† Uï¼ŒX å˜æˆäº† V
                    u = (z - minZ) / rangeZ;

                    if (diffX > 0) {
                        // Qian åœ¨ +X æ–¹å‘
                        v = (x - minX) / rangeX;
                    } else {
                        // Qian åœ¨ -X æ–¹å‘
                        v = 1.0 - ((x - minX) / rangeX);
                    }
                }

                uvs.push(u, v);
            }

            floorMesh.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs);
            console.log("âœ… åº•é¢ UV å·²æ ¹æ® [å‰/å] åæ ‡æ™ºèƒ½å¯¹é½");
        }

        // å¤‡ç”¨ï¼šæ™®é€šçš„ UV é“ºæ»¡ (å¦‚æœæ‰¾ä¸åˆ°å‰åå‚ç…§ç‰©)
        function fixFloorUVsDefault(mesh) {
            const positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            let minX = 1e9, maxX = -1e9, minZ = 1e9, maxZ = -1e9;
            for (let i = 0; i < positions.length; i += 3) {
                if (positions[i] < minX) minX = positions[i]; if (positions[i] > maxX) maxX = positions[i];
                if (positions[i + 2] < minZ) minZ = positions[i + 2]; if (positions[i + 2] > maxZ) maxZ = positions[i + 2];
            }
            const rX = maxX - minX || 1, rZ = maxZ - minZ || 1;
            const uvs = [];
            for (let i = 0; i < positions.length; i += 3) uvs.push((positions[i] - minX) / rX, (positions[i + 2] - minZ) / rZ);
            mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs);
        }

        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());
    </script>
</body>

</html>