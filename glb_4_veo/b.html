<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ¨¡å‹äº”é¢ç‹¬ç«‹è§†é¢‘æ’­æ”¾</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #111;
            font-family: 'Segoe UI', sans-serif;
        }

        #renderCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;

            /* å…³é”®ä»£ç ï¼šç¦æ­¢æµè§ˆå™¨å¤„ç†è§¦æ‘¸å’Œæ»šè½®æ‰‹åŠ¿ */
            touch-action: none;

            outline: none;
            z-index: 1;
        }

        /* æ§åˆ¶é¢æ¿ */
        .controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100;
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(8px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            box-sizing: border-box;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
            min-width: 80px;
        }

        .control-group label {
            font-size: 11px;
            color: #bbb;
            font-weight: 600;
        }

        .input-row {
            display: flex;
            gap: 4px;
        }

        /* æŒ‰é’®æ ·å¼ */
        .btn-file {
            position: relative;
            overflow: hidden;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            color: #eee;
            transition: all 0.2s;
            height: 24px;
            white-space: nowrap;
        }

        .btn-file:hover {
            background: #444;
            border-color: #888;
        }

        .btn-file input[type=file] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
        }

        .btn-blue {
            background: #0066cc;
            border-color: #005bb5;
            color: white;
        }

        /* ä¸‹æ‹‰æ¡†æ ·å¼ */
        .rot-select {
            background: #222;
            color: #eee;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 0 2px;
            height: 26px;
            font-size: 12px;
            cursor: pointer;
            outline: none;
        }

        .rot-select:hover {
            border-color: #888;
        }

        .divider {
            width: 1px;
            height: 35px;
            background: rgba(255, 255, 255, 0.15);
            margin: 0 5px;
        }

        .status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 50;
            color: #00ff99;
            font-size: 13px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 4px;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>

<body>

    <div class="controls">
        <div class="control-group">
            <label>æ¨¡å‹ (GLB)</label>
            <div class="btn-file btn-blue">
                ğŸ“¦ å¯¼å…¥
                <input type="file" id="fileGLB" accept=".glb,.gltf">
            </div>
        </div>

        <div class="divider"></div>

        <div class="control-group">
            <label>å‰ (box_qian)</label>
            <div class="input-row">
                <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_qian" accept="video/*">
                </div>
                <select class="rot-select" data-face="box_qian">
                    <option value="0">0Â°</option>
                    <option value="90">90Â°</option>
                    <option value="180">180Â°</option>
                    <option value="270">270Â°</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label>å (box_hou)</label>
            <div class="input-row">
                <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_hou" accept="video/*">
                </div>
                <select class="rot-select" data-face="box_hou">
                    <option value="0">0Â°</option>
                    <option value="90">90Â°</option>
                    <option value="180">180Â°</option>
                    <option value="270">270Â°</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label>å·¦ (box_zuo)</label>
            <div class="input-row">
                <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_zuo" accept="video/*">
                </div>
                <select class="rot-select" data-face="box_zuo">
                    <option value="0">0Â°</option>
                    <option value="90">90Â°</option>
                    <option value="180">180Â°</option>
                    <option value="270">270Â°</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label>å³ (box_you)</label>
            <div class="input-row">
                <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_you" accept="video/*">
                </div>
                <select class="rot-select" data-face="box_you">
                    <option value="0">0Â°</option>
                    <option value="90">90Â°</option>
                    <option value="180">180Â°</option>
                    <option value="270">270Â°</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label>åº• (box_di)</label>
            <div class="input-row">
                <div class="btn-file">ğŸ¬ è§†é¢‘<input type="file" class="video-input" data-face="box_di" accept="video/*">
                </div>
                <select class="rot-select" data-face="box_di">
                    <option value="0">0Â°</option>
                    <option value="90">90Â°</option>
                    <option value="180">180Â°</option>
                    <option value="270">270Â°</option>
                </select>
            </div>
        </div>
    </div>

    <div id="status" class="status">ç­‰å¾…å¯¼å…¥ GLB æ¨¡å‹...</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        // === 1. åˆå§‹åŒ– Babylon å¼•æ“ ===
        const canvas = document.getElementById("renderCanvas");

        // === æ–°å¢ä¿®å¤ä»£ç ï¼šé˜²æ­¢ç½‘é¡µéšæ»šè½®æ»šåŠ¨æˆ–ç¼©æ”¾ ===
        canvas.addEventListener("wheel", function (evt) {
            // é˜»æ­¢æµè§ˆå™¨çš„é»˜è®¤æ»šåŠ¨/ç¼©æ”¾è¡Œä¸º
            evt.preventDefault();
        }, { passive: false }); // æ³¨æ„ï¼špassive: false æ˜¯å¿…é¡»çš„ï¼Œå¦åˆ™æ— æ³• preventDefault
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.08, 0.08, 0.1, 1);

        const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 10, new BABYLON.Vector3(0, 0, 0), scene);
        camera.attachControl(canvas, true);
        camera.wheelPrecision = 20; camera.minZ = 0.1;

        const hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
        hemiLight.intensity = 0.8;
        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
        dirLight.intensity = 0.5;

        // === æè´¨æ˜ å°„è¡¨ (Updated for 5 Faces) ===
        // key: UI data-face å±æ€§
        // name: GLBæ¨¡å‹ä¸­çš„æè´¨åç§°
        let materialsMap = {
            'box_qian': { name: 'box_qian', matObject: null, texture: null, currentRotation: 0 },
            'box_hou': { name: 'box_hou', matObject: null, texture: null, currentRotation: 0 },
            'box_zuo': { name: 'box_zuo', matObject: null, texture: null, currentRotation: 0 },
            'box_you': { name: 'box_you', matObject: null, texture: null, currentRotation: 0 },
            'box_di': { name: 'box_di', matObject: null, texture: null, currentRotation: 0 }
        };

        // === 2. åŠ è½½æ¨¡å‹ ===
        document.getElementById('fileGLB').onchange = (evt) => {
            const file = evt.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            document.getElementById('status').innerText = "åŠ è½½æ¨¡å‹ä¸­...";

            BABYLON.SceneLoader.ImportMeshAsync("", url, "", scene, null, ".glb").then((result) => {
                const root = result.meshes[0];
                root.normalizeToUnitCube();
                document.getElementById('status').innerText = "æ¨¡å‹å°±ç»ªï¼Œè¯·ä¸Šä¼ è§†é¢‘";

                // 2.1 ç»‘å®šæè´¨
                let foundCount = 0;
                for (let key in materialsMap) {
                    const targetName = materialsMap[key].name;
                    // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬æŸ¥æ‰¾çš„æ˜¯ Material Name
                    const foundMat = scene.getMaterialByName(targetName);

                    if (foundMat) {
                        materialsMap[key].matObject = foundMat;
                        foundMat.roughness = 1.0;
                        foundMat.metallic = 0.0;
                        foundMat.albedoColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                        foundCount++;
                        console.log(`âœ… æ‰¾åˆ°æè´¨: ${targetName}`);
                    } else {
                        console.warn(`âŒ æœªæ‰¾åˆ°æè´¨: ${targetName}`);
                    }
                }

                // 2.2 ä¿®å¤åº•é¢ UV (box_di)
                result.meshes.forEach(m => {
                    // å¦‚æœç½‘æ ¼ä½¿ç”¨çš„æè´¨æ˜¯ box_diï¼Œåˆ™è¿›è¡Œ UV é‡ç®—
                    if (m.material && m.material.name === materialsMap['box_di'].name) {
                        fixFloorUVs(m);
                        console.log(`ğŸ”§ å·²ä¿®å¤ [${m.name}] çš„ UV (box_di)`);
                    }
                });

                document.getElementById('status').innerText = `åŠ è½½å®Œæˆ (åŒ¹é…åˆ° ${foundCount}/5 ä¸ªæè´¨)`;

            }).catch(err => {
                console.error(err);
                document.getElementById('status').innerText = "åŠ è½½å¤±è´¥";
            });
        };

        // === 3. æ—‹è½¬æ§åˆ¶ ===
        document.querySelectorAll('.rot-select').forEach(select => {
            select.onchange = (evt) => {
                const face = evt.target.dataset.face;
                const radians = parseInt(evt.target.value) * (Math.PI / 180);
                materialsMap[face].currentRotation = radians;
                if (materialsMap[face].texture) {
                    materialsMap[face].texture.wAng = radians;
                }
            };
        });

        // === 4. è§†é¢‘ä¸Šä¼  ===
        document.querySelectorAll('.video-input').forEach(input => {
            input.onchange = (evt) => {
                const file = evt.target.files[0];
                const face = evt.target.dataset.face;

                if (!file) return;
                if (!materialsMap[face].matObject) {
                    alert(`æ¨¡å‹ä¸­æœªæ‰¾åˆ°åä¸º "${materialsMap[face].name}" çš„æè´¨`);
                    return;
                }

                applyVideoToFace(face, URL.createObjectURL(file));
            };
        });

        function applyVideoToFace(faceKey, videoUrl) {
            const target = materialsMap[faceKey];
            if (!target.matObject) return;
            if (target.texture) target.texture.dispose();

            const videoTexture = new BABYLON.VideoTexture(
                `vid_${faceKey}`, videoUrl, scene, true, false,
                BABYLON.Texture.TRILINEAR_SAMPLINGMODE,
                { autoPlay: true, loop: true, muted: true }
            );

            // æ—‹è½¬ä¸­å¿ƒå±…ä¸­
            videoTexture.uRotationCenter = 0.5;
            videoTexture.vRotationCenter = 0.5;

            // åº”ç”¨å½“å‰é€‰æ‹©çš„æ—‹è½¬è§’åº¦
            videoTexture.wAng = target.currentRotation;

            // ç¿»è½¬å¤„ç†ï¼š
            // box_di (åº•é¢) é€šå¸¸ä¸éœ€è¦å‚ç›´ç¿»è½¬ (vScale=1)
            // å…¶ä»–å¢™é¢ (zuo, you, qian, hou) é€šå¸¸éœ€è¦å‚ç›´ç¿»è½¬ (vScale=-1)
            if (faceKey === 'box_di') {
                videoTexture.vScale = 1;
            } else {
                videoTexture.vScale = -1;
            }

            target.matObject.albedoTexture = videoTexture;
            target.matObject.emissiveTexture = videoTexture;
            target.matObject.emissiveColor = new BABYLON.Color3(1, 1, 1);
            target.texture = videoTexture;
        }

        // === 5. åº•é¢ UV ä¿®å¤ç®—æ³• (ä¸“é—¨é’ˆå¯¹ box_di) ===
        function fixFloorUVs(mesh) {
            const positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            if (!positions) return;

            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i], z = positions[i + 2];
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
            }
            const rangeX = maxX - minX || 1, rangeZ = maxZ - minZ || 1;
            const uvs = [];
            for (let i = 0; i < positions.length; i += 3) {
                // å°†å±€éƒ¨åæ ‡é‡æ–°æ˜ å°„åˆ° 0-1 ç©ºé—´
                uvs.push((positions[i] - minX) / rangeX, (positions[i + 2] - minZ) / rangeZ);
            }
            mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs);
        }

        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());
    </script>
</body>

</html>