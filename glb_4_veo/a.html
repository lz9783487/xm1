<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ¨¡å‹å››é¢ç‹¬ç«‹è§†é¢‘æ’­æ”¾ (å¸¦æ—‹è½¬æ§åˆ¶)</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <style>
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; 
        }

        #renderCanvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            touch-action: none; outline: none; z-index: 1; 
        }

        /* æ§åˆ¶é¢æ¿ */
        .controls {
            position: absolute; top: 0; left: 0; width: 100%; z-index: 100;
            background: rgba(20, 20, 20, 0.9); backdrop-filter: blur(8px);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 10px 20px; box-sizing: border-box;
            display: flex; gap: 15px; align-items: center; justify-content: center; flex-wrap: wrap; 
        }

        .control-group { 
            display: flex; flex-direction: column; gap: 4px; align-items: center; 
            min-width: 90px;
        }
        .control-group label { font-size: 11px; color: #bbb; font-weight: 600; text-transform: uppercase; }
        
        /* è¿™ä¸€è¡ŒåŒ…å« ä¸Šä¼ æŒ‰é’® å’Œ æ—‹è½¬ä¸‹æ‹‰æ¡† */
        .input-row { display: flex; gap: 5px; }

        /* æŒ‰é’®æ ·å¼ */
        .btn-file {
            position: relative; overflow: hidden; display: inline-flex; align-items: center; justify-content: center;
            background: #333; border: 1px solid #555; border-radius: 4px;
            padding: 4px 10px; cursor: pointer; font-size: 12px; color: #eee; transition: all 0.2s;
            height: 24px;
        }
        .btn-file:hover { background: #444; border-color: #888; }
        .btn-file input[type=file] { position: absolute; opacity: 0; cursor: pointer; width: 100%; height: 100%; left:0; top:0;}
        .btn-blue { background: #0066cc; border-color: #005bb5; color: white; }
        
        /* ä¸‹æ‹‰æ¡†æ ·å¼ */
        .rot-select {
            background: #222; color: #eee; border: 1px solid #555; border-radius: 4px;
            padding: 0 5px; height: 26px; font-size: 12px; cursor: pointer; outline: none;
        }
        .rot-select:hover { border-color: #888; }

        .divider { width: 1px; height: 35px; background: rgba(255,255,255,0.15); margin: 0 5px; }

        .status { 
            position: absolute; bottom: 20px; left: 20px; z-index: 50;
            color: #00ff99; font-size: 13px; background: rgba(0,0,0,0.7);
            padding: 6px 12px; border-radius: 4px; pointer-events: none; user-select: none;
        }
    </style>
</head>
<body>

    <div class="controls">
        <div class="control-group">
            <label>1. æ¨¡å‹</label>
            <div class="btn-file btn-blue">
                ğŸ“¦ GLB
                <input type="file" id="fileGLB" accept=".glb,.gltf">
            </div>
        </div>

        <div class="divider"></div>

        <div class="control-group">
            <label>2. èƒŒé¢ (Back)</label>
            <div class="input-row">
                <div class="btn-file">
                    ğŸ¬ è§†é¢‘
                    <input type="file" class="video-input" data-face="back" accept="video/*">
                </div>
                <select class="rot-select" data-face="back">
                    <option value="0">0Â°</option>
                    <option value="90">90Â°</option>
                    <option value="180">180Â°</option>
                    <option value="270">270Â°</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label>3. å·¦ä¾§ (Left)</label>
            <div class="input-row">
                <div class="btn-file">
                    ğŸ¬ è§†é¢‘
                    <input type="file" class="video-input" data-face="left" accept="video/*">
                </div>
                <select class="rot-select" data-face="left">
                    <option value="0">0Â°</option>
                    <option value="90">90Â°</option>
                    <option value="180">180Â°</option>
                    <option value="270">270Â°</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label>4. å³ä¾§ (Right)</label>
            <div class="input-row">
                <div class="btn-file">
                    ğŸ¬ è§†é¢‘
                    <input type="file" class="video-input" data-face="right" accept="video/*">
                </div>
                <select class="rot-select" data-face="right">
                    <option value="0">0Â°</option>
                    <option value="90">90Â°</option>
                    <option value="180">180Â°</option>
                    <option value="270">270Â°</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label>5. åœ°é¢ (Floor)</label>
            <div class="input-row">
                <div class="btn-file">
                    ğŸ¬ è§†é¢‘
                    <input type="file" class="video-input" data-face="floor" accept="video/*">
                </div>
                <select class="rot-select" data-face="floor">
                    <option value="0">0Â°</option>
                    <option value="90">90Â°</option>
                    <option value="180">180Â°</option>
                    <option value="270">270Â°</option>
                </select>
            </div>
        </div>
    </div>

    <div id="status" class="status">ç­‰å¾…å¯¼å…¥ GLB æ¨¡å‹...</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        // === 1. åˆå§‹åŒ– Babylon å¼•æ“ ===
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.08, 0.08, 0.1, 1);

        const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 8, new BABYLON.Vector3(0, 0, 0), scene);
        camera.attachControl(canvas, true);
        camera.wheelPrecision = 50; camera.minZ = 0.1;

        const hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
        hemiLight.intensity = 0.8;
        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
        dirLight.intensity = 0.5;

        // æè´¨æ˜ å°„è¡¨ï¼šå¢åŠ  currentRotation å­—æ®µæ¥å­˜å‚¨å½“å‰çš„å¼§åº¦
        let materialsMap = {
            'back':  { name: 'Material.003', matObject: null, texture: null, currentRotation: 0 },
            'left':  { name: 'Material.002', matObject: null, texture: null, currentRotation: 0 },
            'right': { name: 'Material.004', matObject: null, texture: null, currentRotation: 0 },
            'floor': { name: 'Material.005', matObject: null, texture: null, currentRotation: 0 }
        };

        // === 2. åŠ è½½æ¨¡å‹ ===
        document.getElementById('fileGLB').onchange = (evt) => {
            const file = evt.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            document.getElementById('status').innerText = "åŠ è½½æ¨¡å‹ä¸­...";

            BABYLON.SceneLoader.ImportMeshAsync("", url, "", scene, null, ".glb").then((result) => {
                const root = result.meshes[0];
                root.normalizeToUnitCube();
                document.getElementById('status').innerText = "æ¨¡å‹å°±ç»ªï¼Œè¯·ä¸Šä¼ è§†é¢‘å¹¶è°ƒèŠ‚æ—‹è½¬";

                for (let key in materialsMap) {
                    const targetName = materialsMap[key].name;
                    const foundMat = scene.getMaterialByName(targetName);
                    if (foundMat) {
                        materialsMap[key].matObject = foundMat;
                        foundMat.roughness = 1.0; foundMat.metallic = 0.0;
                        foundMat.albedoColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                    }
                }

                result.meshes.forEach(m => {
                    if (m.material && m.material.name === materialsMap.floor.name) fixFloorUVs(m);
                });

            }).catch(console.error);
        };

        // === 3. å¤„ç†æ—‹è½¬é€»è¾‘ (ä¸‹æ‹‰æ¡†) ===
        document.querySelectorAll('.rot-select').forEach(select => {
            select.onchange = (evt) => {
                const face = evt.target.dataset.face;
                const degrees = parseInt(evt.target.value);
                // è½¬æ¢ä¸ºå¼§åº¦: è§’åº¦ * (PI / 180)
                const radians = degrees * (Math.PI / 180);

                // 1. æ›´æ–°æ•°æ®è®°å½•
                materialsMap[face].currentRotation = radians;

                // 2. å¦‚æœå½“å‰æœ‰è§†é¢‘çº¹ç†ï¼Œç«‹å³åº”ç”¨
                if (materialsMap[face].texture) {
                    materialsMap[face].texture.wAng = radians;
                }
            };
        });

        // === 4. å¤„ç†è§†é¢‘ä¸Šä¼  ===
        document.querySelectorAll('.video-input').forEach(input => {
            input.onchange = (evt) => {
                const file = evt.target.files[0];
                const face = evt.target.dataset.face;
                if (!file || !materialsMap[face].matObject) return;
                
                applyVideoToFace(face, URL.createObjectURL(file));
            };
        });

        function applyVideoToFace(faceKey, videoUrl) {
            const target = materialsMap[faceKey];
            if (!target.matObject) return;
            if (target.texture) target.texture.dispose();

            const videoTexture = new BABYLON.VideoTexture(
                `vid_${faceKey}`, videoUrl, scene, true, false, 
                BABYLON.Texture.TRILINEAR_SAMPLINGMODE, 
                { autoPlay: true, loop: true, muted: true }
            );

            // === å…³é”®ä¿®æ”¹ï¼šåº”ç”¨æ—‹è½¬ ===
            
            // 1. è®¾ç½®æ—‹è½¬ä¸­å¿ƒä¸ºå›¾ç‰‡ä¸­å¿ƒï¼Œå¦åˆ™æ—‹è½¬æ—¶å›¾ç‰‡ä¼šè·‘å
            videoTexture.uRotationCenter = 0.5;
            videoTexture.vRotationCenter = 0.5;

            // 2. è¯»å–å½“å‰ä¸‹æ‹‰æ¡†è®¾å®šçš„æ—‹è½¬å€¼å¹¶åº”ç”¨
            videoTexture.wAng = target.currentRotation;

            // 3. å¤„ç†ç¿»è½¬ (GLB æ ‡å‡†å¤„ç†)
            // åœ°é¢é€šå¸¸ä¸éœ€è¦ç¿»è½¬ (vScale=1)ï¼Œå¢™é¢é€šå¸¸éœ€è¦å‚ç›´ç¿»è½¬ (vScale=-1)
            if (faceKey === 'floor') {
                videoTexture.vScale = 1; 
            } else {
                videoTexture.vScale = -1;
            }
            
            // 4. åº”ç”¨æè´¨
            target.matObject.albedoTexture = videoTexture;
            target.matObject.emissiveTexture = videoTexture;
            target.matObject.emissiveColor = new BABYLON.Color3(1, 1, 1);
            target.texture = videoTexture;
        }

        // === 5. åœ°é¢ UV ä¿®å¤ (ä¿æŒä¸å˜) ===
        function fixFloorUVs(mesh) {
            const positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            if (!positions) return;

            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i], z = positions[i + 2];
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
            }
            const rangeX = maxX - minX || 1, rangeZ = maxZ - minZ || 1;
            const uvs = [];
            for (let i = 0; i < positions.length; i += 3) {
                uvs.push((positions[i] - minX) / rangeX, (positions[i + 2] - minZ) / rangeZ);
            }
            mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs);
        }

        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());
    </script>
</body>
</html>